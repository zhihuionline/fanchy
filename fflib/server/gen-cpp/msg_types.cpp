/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "msg_types.h"

#include <algorithm>

namespace msgtype {

int _kPropTypeDefValues[] = {
  PropTypeDef::HP,
  PropTypeDef::MP,
  PropTypeDef::HP_MAX,
  PropTypeDef::MP_MAX,
  PropTypeDef::PHYSIC_ATTACK_MIN,
  PropTypeDef::PHYSIC_ATTACK_MAX,
  PropTypeDef::MAGIC_ATTACK_MIN,
  PropTypeDef::MAGIC_ATTACK_MAX,
  PropTypeDef::PHYSIC_DEFEND_MIN,
  PropTypeDef::PHYSIC_DEFEND_MAX,
  PropTypeDef::MAGIC_DEFEND_MIN,
  PropTypeDef::MAGIC_DEFEND_MAX,
  PropTypeDef::CRIT,
  PropTypeDef::HIT,
  PropTypeDef::AVOID,
  PropTypeDef::ATTACK_SPEED,
  PropTypeDef::ATTACK_SING,
  PropTypeDef::ATTACK_INTERVAL,
  PropTypeDef::ATTACK_DISTANCE,
  PropTypeDef::MOVE_SPEED,
  PropTypeDef::HURT_ABSORB,
  PropTypeDef::HP_ABSORB
};
const char* _kPropTypeDefNames[] = {
  "HP",
  "MP",
  "HP_MAX",
  "MP_MAX",
  "PHYSIC_ATTACK_MIN",
  "PHYSIC_ATTACK_MAX",
  "MAGIC_ATTACK_MIN",
  "MAGIC_ATTACK_MAX",
  "PHYSIC_DEFEND_MIN",
  "PHYSIC_DEFEND_MAX",
  "MAGIC_DEFEND_MIN",
  "MAGIC_DEFEND_MAX",
  "CRIT",
  "HIT",
  "AVOID",
  "ATTACK_SPEED",
  "ATTACK_SING",
  "ATTACK_INTERVAL",
  "ATTACK_DISTANCE",
  "MOVE_SPEED",
  "HURT_ABSORB",
  "HP_ABSORB"
};
const std::map<int, const char*> _PropTypeDef_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(22, _kPropTypeDefValues, _kPropTypeDefNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kClientCmdValues[] = {
  ClientCmd::LOGIN,
  ClientCmd::RAND_NAME,
  ClientCmd::DEL_ROLE,
  ClientCmd::CREATE_ROLE,
  ClientCmd::SELECT_ROLE,
  ClientCmd::ENTER_MAP,
  ClientCmd::MOVE,
  ClientCmd::QUERY_SKILL,
  ClientCmd::LEARN_SKILL,
  ClientCmd::USE_SKILL,
  ClientCmd::QUERY_TASK_LIST,
  ClientCmd::UPDATE_TASK_STATUS,
  ClientCmd::QUERY_PKG,
  ClientCmd::ARRANGE_PKG,
  ClientCmd::QUERY_EQUIP,
  ClientCmd::EQUIP_ITEM,
  ClientCmd::UNEQUIP_ITEM,
  ClientCmd::THROW_ITEM,
  ClientCmd::PICKUP_ITEM,
  ClientCmd::STRENGTHEN_ITEM,
  ClientCmd::CLICK_NPC,
  ClientCmd::GET_FRIENDLIST,
  ClientCmd::FRIENDLIST_OPS,
  ClientCmd::CHAT_OPS,
  ClientCmd::SERVER_CALLBACK,
  ClientCmd::USE_ITEM,
  ClientCmd::DIEJIA_ITEM,
  ClientCmd::UPDATE_SKILL_POS,
  ClientCmd::MAKE_ITEM,
  ClientCmd::INHERIT_ITEM,
  ClientCmd::REPO_ITEM_OPS,
  ClientCmd::EXCHANGE_OPS,
  ClientCmd::MONEY_BANK_QUERY,
  ClientCmd::MONEY_BANK_OPS,
  ClientCmd::ITEM_EXTRA_OPS,
  ClientCmd::AUCTION_OPS,
  ClientCmd::GET_TEAMLIST,
  ClientCmd::TEAMLIST_OPS,
  ClientCmd::GET_GUILDINFO,
  ClientCmd::GET_USER_GUILD_INFO,
  ClientCmd::GUILD_OPS,
  ClientCmd::GUILD_INFO_OPS,
  ClientCmd::GUILD_LEVEL_OPS,
  ClientCmd::GUILD_WAR_OPS,
  ClientCmd::GUILD_CITYWAR_OPS,
  ClientCmd::COLLECT_OPS,
  ClientCmd::TRANSFER_POINT_OPS,
  ClientCmd::PET_QUERY,
  ClientCmd::PET_EGG_START,
  ClientCmd::PET_EGG_COMPLETE,
  ClientCmd::PET_FEED,
  ClientCmd::PET_OUT,
  ClientCmd::PET_IN,
  ClientCmd::BROTHER_QUERY,
  ClientCmd::BROTHER_OPS,
  ClientCmd::MARRIAGE_OPS,
  ClientCmd::ARENA_OPS,
  ClientCmd::QIECUO_OPS,
  ClientCmd::ATTACK_MODE_OPS,
  ClientCmd::HELP_ATTACK_OPS,
  ClientCmd::XIBAI_OPS,
  ClientCmd::MAIL_OPS,
  ClientCmd::RANK_OPS,
  ClientCmd::HEART_BEAT,
  ClientCmd::DAILY_LOGIN_OPS
};
const char* _kClientCmdNames[] = {
  "LOGIN",
  "RAND_NAME",
  "DEL_ROLE",
  "CREATE_ROLE",
  "SELECT_ROLE",
  "ENTER_MAP",
  "MOVE",
  "QUERY_SKILL",
  "LEARN_SKILL",
  "USE_SKILL",
  "QUERY_TASK_LIST",
  "UPDATE_TASK_STATUS",
  "QUERY_PKG",
  "ARRANGE_PKG",
  "QUERY_EQUIP",
  "EQUIP_ITEM",
  "UNEQUIP_ITEM",
  "THROW_ITEM",
  "PICKUP_ITEM",
  "STRENGTHEN_ITEM",
  "CLICK_NPC",
  "GET_FRIENDLIST",
  "FRIENDLIST_OPS",
  "CHAT_OPS",
  "SERVER_CALLBACK",
  "USE_ITEM",
  "DIEJIA_ITEM",
  "UPDATE_SKILL_POS",
  "MAKE_ITEM",
  "INHERIT_ITEM",
  "REPO_ITEM_OPS",
  "EXCHANGE_OPS",
  "MONEY_BANK_QUERY",
  "MONEY_BANK_OPS",
  "ITEM_EXTRA_OPS",
  "AUCTION_OPS",
  "GET_TEAMLIST",
  "TEAMLIST_OPS",
  "GET_GUILDINFO",
  "GET_USER_GUILD_INFO",
  "GUILD_OPS",
  "GUILD_INFO_OPS",
  "GUILD_LEVEL_OPS",
  "GUILD_WAR_OPS",
  "GUILD_CITYWAR_OPS",
  "COLLECT_OPS",
  "TRANSFER_POINT_OPS",
  "PET_QUERY",
  "PET_EGG_START",
  "PET_EGG_COMPLETE",
  "PET_FEED",
  "PET_OUT",
  "PET_IN",
  "BROTHER_QUERY",
  "BROTHER_OPS",
  "MARRIAGE_OPS",
  "ARENA_OPS",
  "QIECUO_OPS",
  "ATTACK_MODE_OPS",
  "HELP_ATTACK_OPS",
  "XIBAI_OPS",
  "MAIL_OPS",
  "RANK_OPS",
  "HEART_BEAT",
  "DAILY_LOGIN_OPS"
};
const std::map<int, const char*> _ClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(65, _kClientCmdValues, _kClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kServerCmdValues[] = {
  ServerCmd::USER_INFO,
  ServerCmd::FRIENDLIST,
  ServerCmd::LOGOUT,
  ServerCmd::ERROR_MSG,
  ServerCmd::RELOGIN,
  ServerCmd::RAND_NAME,
  ServerCmd::DEL_ROLE,
  ServerCmd::CREATE_ROLE_RET,
  ServerCmd::ENTER_MAP,
  ServerCmd::LEAVE_MAP,
  ServerCmd::MOVE,
  ServerCmd::UPDATE_EXP,
  ServerCmd::QUERY_SKILL,
  ServerCmd::LEARN_SKILL,
  ServerCmd::USE_SKILL,
  ServerCmd::HURT_RESULT,
  ServerCmd::MONSTER_ENTER_MAP,
  ServerCmd::QUERY_TASK_LIST,
  ServerCmd::UPDATE_TASK_STATUS,
  ServerCmd::UPDATE_PROP,
  ServerCmd::SYNC_HPMP,
  ServerCmd::QUERY_PKG,
  ServerCmd::QUERY_EQUIP,
  ServerCmd::EQUIP_ITEM,
  ServerCmd::UNEQUIP_ITEM,
  ServerCmd::ITEM_ENTER_MAP,
  ServerCmd::THROW_ITEM,
  ServerCmd::PICKUP_ITEM,
  ServerCmd::STRENGTHEN_ITEM,
  ServerCmd::NPC_ENTER_MAP,
  ServerCmd::CLICK_NPC,
  ServerCmd::FRIENDLIST_MSG,
  ServerCmd::FRIEHND_MSG,
  ServerCmd::CHAT_MSG,
  ServerCmd::TEAMLIST_MSG,
  ServerCmd::TEAM_MSG,
  ServerCmd::GUILDINFO_MSG,
  ServerCmd::GUILD_INFO_LIST_MSG,
  ServerCmd::GUILD_OPS_MSG,
  ServerCmd::GUILD_INFO_MSG,
  ServerCmd::GUILD_LEVEL_MSG,
  ServerCmd::GUILD_WAR_OPS,
  ServerCmd::CHANGE_APPR,
  ServerCmd::GUILD_CITYWAR_MSG,
  ServerCmd::SHOW_TASK_PANEL,
  ServerCmd::USE_ITEM,
  ServerCmd::DIEJIA_ITEM,
  ServerCmd::UPDATE_SKILL_POS,
  ServerCmd::MAKE_ITEM,
  ServerCmd::INHERIT_ITEM,
  ServerCmd::UPDATE_BUFF,
  ServerCmd::MONSTER_BURST_ITEMS,
  ServerCmd::REPO_ITEM_OPS,
  ServerCmd::EXCHANGE_OPS,
  ServerCmd::MONEY_BANK_QUERY,
  ServerCmd::MONEY_BANK_OPS,
  ServerCmd::ITEM_EXTRA_OPS,
  ServerCmd::AUCTION_OPS,
  ServerCmd::UPDATE_PET_EXP,
  ServerCmd::PET_QUERY,
  ServerCmd::PET_OUT,
  ServerCmd::PET_IN,
  ServerCmd::SHOW_PLAY,
  ServerCmd::SHOW_UI,
  ServerCmd::COLLECT_OPS,
  ServerCmd::COPYMAP_START,
  ServerCmd::COPYMAP_END,
  ServerCmd::BROTHER_OPS_MSG,
  ServerCmd::MARRIAGE_OPS_MSG,
  ServerCmd::MAIL_OPS_MSG,
  ServerCmd::ARENA_OPS,
  ServerCmd::QIECUO_OPS,
  ServerCmd::ATTACK_MODE_OPS,
  ServerCmd::PK_SIN_UPDATE_OPS,
  ServerCmd::HELP_ATTACK_OPS,
  ServerCmd::REBORN,
  ServerCmd::XIBAI_OPS,
  ServerCmd::RANK_OPS_MSG,
  ServerCmd::SHOW_EFFECT,
  ServerCmd::HEART_BEAT,
  ServerCmd::DAILY_LOGIN_OPS_MSG
};
const char* _kServerCmdNames[] = {
  "USER_INFO",
  "FRIENDLIST",
  "LOGOUT",
  "ERROR_MSG",
  "RELOGIN",
  "RAND_NAME",
  "DEL_ROLE",
  "CREATE_ROLE_RET",
  "ENTER_MAP",
  "LEAVE_MAP",
  "MOVE",
  "UPDATE_EXP",
  "QUERY_SKILL",
  "LEARN_SKILL",
  "USE_SKILL",
  "HURT_RESULT",
  "MONSTER_ENTER_MAP",
  "QUERY_TASK_LIST",
  "UPDATE_TASK_STATUS",
  "UPDATE_PROP",
  "SYNC_HPMP",
  "QUERY_PKG",
  "QUERY_EQUIP",
  "EQUIP_ITEM",
  "UNEQUIP_ITEM",
  "ITEM_ENTER_MAP",
  "THROW_ITEM",
  "PICKUP_ITEM",
  "STRENGTHEN_ITEM",
  "NPC_ENTER_MAP",
  "CLICK_NPC",
  "FRIENDLIST_MSG",
  "FRIEHND_MSG",
  "CHAT_MSG",
  "TEAMLIST_MSG",
  "TEAM_MSG",
  "GUILDINFO_MSG",
  "GUILD_INFO_LIST_MSG",
  "GUILD_OPS_MSG",
  "GUILD_INFO_MSG",
  "GUILD_LEVEL_MSG",
  "GUILD_WAR_OPS",
  "CHANGE_APPR",
  "GUILD_CITYWAR_MSG",
  "SHOW_TASK_PANEL",
  "USE_ITEM",
  "DIEJIA_ITEM",
  "UPDATE_SKILL_POS",
  "MAKE_ITEM",
  "INHERIT_ITEM",
  "UPDATE_BUFF",
  "MONSTER_BURST_ITEMS",
  "REPO_ITEM_OPS",
  "EXCHANGE_OPS",
  "MONEY_BANK_QUERY",
  "MONEY_BANK_OPS",
  "ITEM_EXTRA_OPS",
  "AUCTION_OPS",
  "UPDATE_PET_EXP",
  "PET_QUERY",
  "PET_OUT",
  "PET_IN",
  "SHOW_PLAY",
  "SHOW_UI",
  "COLLECT_OPS",
  "COPYMAP_START",
  "COPYMAP_END",
  "BROTHER_OPS_MSG",
  "MARRIAGE_OPS_MSG",
  "MAIL_OPS_MSG",
  "ARENA_OPS",
  "QIECUO_OPS",
  "ATTACK_MODE_OPS",
  "PK_SIN_UPDATE_OPS",
  "HELP_ATTACK_OPS",
  "REBORN",
  "XIBAI_OPS",
  "RANK_OPS_MSG",
  "SHOW_EFFECT",
  "HEART_BEAT",
  "DAILY_LOGIN_OPS_MSG"
};
const std::map<int, const char*> _ServerCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(81, _kServerCmdValues, _kServerCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGuildLevelClientCmdValues[] = {
  GuildLevelClientCmd::UP_GUILD_LEVEL,
  GuildLevelClientCmd::UP_GUILD_EXP
};
const char* _kGuildLevelClientCmdNames[] = {
  "UP_GUILD_LEVEL",
  "UP_GUILD_EXP"
};
const std::map<int, const char*> _GuildLevelClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGuildLevelClientCmdValues, _kGuildLevelClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGuildInfoClientCmdValues[] = {
  GuildInfoClientCmd::GET_GUILD_ALL,
  GuildInfoClientCmd::GET_GUILD_BY_NAME
};
const char* _kGuildInfoClientCmdNames[] = {
  "GET_GUILD_ALL",
  "GET_GUILD_BY_NAME"
};
const std::map<int, const char*> _GuildInfoClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGuildInfoClientCmdValues, _kGuildInfoClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGuildOpsClientCmdValues[] = {
  GuildOpsClientCmd::CREATE_GUILD,
  GuildOpsClientCmd::REQUEST_ADD_GUILD,
  GuildOpsClientCmd::VERIFY_REQUEST_ADD_GUILD,
  GuildOpsClientCmd::REFUSE_REQUEST_ADD_GUILD,
  GuildOpsClientCmd::INVITE_ADD_GUILD,
  GuildOpsClientCmd::VERIFY_INVIT_ADD_GUILD,
  GuildOpsClientCmd::REFUSE_INVITT_ADD_GUILD,
  GuildOpsClientCmd::EXIT_GUILD,
  GuildOpsClientCmd::DEL_GUILD_MEMBER,
  GuildOpsClientCmd::UP_GUILD_LEADER,
  GuildOpsClientCmd::UP_GUILD_SECOND_LEADER,
  GuildOpsClientCmd::UP_MEMBER,
  GuildOpsClientCmd::OPEN_COPY_MAP,
  GuildOpsClientCmd::ENTER_COPY_MAP
};
const char* _kGuildOpsClientCmdNames[] = {
  "CREATE_GUILD",
  "REQUEST_ADD_GUILD",
  "VERIFY_REQUEST_ADD_GUILD",
  "REFUSE_REQUEST_ADD_GUILD",
  "INVITE_ADD_GUILD",
  "VERIFY_INVIT_ADD_GUILD",
  "REFUSE_INVITT_ADD_GUILD",
  "EXIT_GUILD",
  "DEL_GUILD_MEMBER",
  "UP_GUILD_LEADER",
  "UP_GUILD_SECOND_LEADER",
  "UP_MEMBER",
  "OPEN_COPY_MAP",
  "ENTER_COPY_MAP"
};
const std::map<int, const char*> _GuildOpsClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(14, _kGuildOpsClientCmdValues, _kGuildOpsClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGuildPostCmdValues[] = {
  GuildPostCmd::MEMBER,
  GuildPostCmd::GUILD_LEADER,
  GuildPostCmd::GUILD_SECOND_LEADER
};
const char* _kGuildPostCmdNames[] = {
  "MEMBER",
  "GUILD_LEADER",
  "GUILD_SECOND_LEADER"
};
const std::map<int, const char*> _GuildPostCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kGuildPostCmdValues, _kGuildPostCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGuildLevelCmdValues[] = {
  GuildLevelCmd::GUILD_LEVRL_1,
  GuildLevelCmd::GUILD_LEVRL_2,
  GuildLevelCmd::GUILD_LEVRL_3,
  GuildLevelCmd::GUILD_LEVRL_4,
  GuildLevelCmd::GUILD_LEVRL_5,
  GuildLevelCmd::GUILD_LEVRL_6,
  GuildLevelCmd::GUILD_LEVRL_7
};
const char* _kGuildLevelCmdNames[] = {
  "GUILD_LEVRL_1",
  "GUILD_LEVRL_2",
  "GUILD_LEVRL_3",
  "GUILD_LEVRL_4",
  "GUILD_LEVRL_5",
  "GUILD_LEVRL_6",
  "GUILD_LEVRL_7"
};
const std::map<int, const char*> _GuildLevelCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kGuildLevelCmdValues, _kGuildLevelCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTaskStatusValues[] = {
  TaskStatus::INIT,
  TaskStatus::ACCEPT,
  TaskStatus::DONE,
  TaskStatus::FINISH
};
const char* _kTaskStatusNames[] = {
  "INIT",
  "ACCEPT",
  "DONE",
  "FINISH"
};
const std::map<int, const char*> _TaskStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kTaskStatusValues, _kTaskStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTaskTypeDefValues[] = {
  TaskTypeDef::MAIN_TASK,
  TaskTypeDef::DAILY_TASK,
  TaskTypeDef::BRANCH_TASK
};
const char* _kTaskTypeDefNames[] = {
  "MAIN_TASK",
  "DAILY_TASK",
  "BRANCH_TASK"
};
const std::map<int, const char*> _TaskTypeDef_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kTaskTypeDefValues, _kTaskTypeDefNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTaskActionDefValues[] = {
  TaskActionDef::NONE_ACTION,
  TaskActionDef::CHAT_NPC,
  TaskActionDef::KILL_MONSTER,
  TaskActionDef::EXPLORE,
  TaskActionDef::COLLECT
};
const char* _kTaskActionDefNames[] = {
  "NONE_ACTION",
  "CHAT_NPC",
  "KILL_MONSTER",
  "EXPLORE",
  "COLLECT"
};
const std::map<int, const char*> _TaskActionDef_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kTaskActionDefValues, _kTaskActionDefNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kECOLORValues[] = {
  ECOLOR::BLUE,
  ECOLOR::YELLOW
};
const char* _kECOLORNames[] = {
  "BLUE",
  "YELLOW"
};
const std::map<int, const char*> _ECOLOR_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kECOLORValues, _kECOLORNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFriendOpsClientCmdValues[] = {
  FriendOpsClientCmd::INVITE_ADD_LISTFRIEND,
  FriendOpsClientCmd::VERIFY_ADD_LISTFRIEND,
  FriendOpsClientCmd::REFUSE_ADD_LISTFRIEND,
  FriendOpsClientCmd::DEL_LISTFRIEND,
  FriendOpsClientCmd::ADD_ENEMY,
  FriendOpsClientCmd::DEL_ENEMY,
  FriendOpsClientCmd::ADD_SHIELD,
  FriendOpsClientCmd::DEL_SHIELD
};
const char* _kFriendOpsClientCmdNames[] = {
  "INVITE_ADD_LISTFRIEND",
  "VERIFY_ADD_LISTFRIEND",
  "REFUSE_ADD_LISTFRIEND",
  "DEL_LISTFRIEND",
  "ADD_ENEMY",
  "DEL_ENEMY",
  "ADD_SHIELD",
  "DEL_SHIELD"
};
const std::map<int, const char*> _FriendOpsClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kFriendOpsClientCmdValues, _kFriendOpsClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFriendListClientCmdValues[] = {
  FriendListClientCmd::GET_FRIENDLIST,
  FriendListClientCmd::GET_FRIENDLIST_TEMP,
  FriendListClientCmd::GET_ENEMY,
  FriendListClientCmd::JUMP_ENEMY
};
const char* _kFriendListClientCmdNames[] = {
  "GET_FRIENDLIST",
  "GET_FRIENDLIST_TEMP",
  "GET_ENEMY",
  "JUMP_ENEMY"
};
const std::map<int, const char*> _FriendListClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFriendListClientCmdValues, _kFriendListClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kChatMsgCmdValues[] = {
  ChatMsgCmd::MapCHAT,
  ChatMsgCmd::PERSONCHAT,
  ChatMsgCmd::WORLDCHAT,
  ChatMsgCmd::TEAMCHAT,
  ChatMsgCmd::GUILDCHAT,
  ChatMsgCmd::SYSTEMCHAT
};
const char* _kChatMsgCmdNames[] = {
  "MapCHAT",
  "PERSONCHAT",
  "WORLDCHAT",
  "TEAMCHAT",
  "GUILDCHAT",
  "SYSTEMCHAT"
};
const std::map<int, const char*> _ChatMsgCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kChatMsgCmdValues, _kChatMsgCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTeamClientCmdValues[] = {
  TeamClientCmd::INVITE_ADD_TEAM,
  TeamClientCmd::VERIFY_INVIT_ADD_TEAM,
  TeamClientCmd::REFUSE_INVITT_ADD_TEAM,
  TeamClientCmd::DEL_TEAMPLAYER,
  TeamClientCmd::QUIT_TEAM,
  TeamClientCmd::REPLACE_TEAMLEADER
};
const char* _kTeamClientCmdNames[] = {
  "INVITE_ADD_TEAM",
  "VERIFY_INVIT_ADD_TEAM",
  "REFUSE_INVITT_ADD_TEAM",
  "DEL_TEAMPLAYER",
  "QUIT_TEAM",
  "REPLACE_TEAMLEADER"
};
const std::map<int, const char*> _TeamClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTeamClientCmdValues, _kTeamClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kTeamListClientCmdValues[] = {
  TeamListClientCmd::GET_TEAMLIST
};
const char* _kTeamListClientCmdNames[] = {
  "GET_TEAMLIST"
};
const std::map<int, const char*> _TeamListClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kTeamListClientCmdValues, _kTeamListClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBrotherClientCmdValues[] = {
  BrotherClientCmd::INVITE_ADD_BROTHER,
  BrotherClientCmd::VERIFY_INVIT_ADD_BROTHER,
  BrotherClientCmd::REFUSE_INVITT_ADD_BROTHER,
  BrotherClientCmd::CONFIRM_INVIT_ADD_BROTHER,
  BrotherClientCmd::QUIT_BROTHER,
  BrotherClientCmd::GET_BROTHERLIST,
  BrotherClientCmd::CONSULT_QUIT_BROTHER,
  BrotherClientCmd::CANCLE_QUIT_BROTHER,
  BrotherClientCmd::DOWN_LINE_BROTHER,
  BrotherClientCmd::LEARN_BRO_SKILL
};
const char* _kBrotherClientCmdNames[] = {
  "INVITE_ADD_BROTHER",
  "VERIFY_INVIT_ADD_BROTHER",
  "REFUSE_INVITT_ADD_BROTHER",
  "CONFIRM_INVIT_ADD_BROTHER",
  "QUIT_BROTHER",
  "GET_BROTHERLIST",
  "CONSULT_QUIT_BROTHER",
  "CANCLE_QUIT_BROTHER",
  "DOWN_LINE_BROTHER",
  "LEARN_BRO_SKILL"
};
const std::map<int, const char*> _BrotherClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kBrotherClientCmdValues, _kBrotherClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kBuffTypeValues[] = {
  BuffType::XUAN_YUN,
  BuffType::JIAN_SU,
  BuffType::SHEN_MING_HU_TI,
  BuffType::GUWU_SHIQI,
  BuffType::ZHIYUSHU,
  BuffType::DEFEND
};
const char* _kBuffTypeNames[] = {
  "XUAN_YUN",
  "JIAN_SU",
  "SHEN_MING_HU_TI",
  "GUWU_SHIQI",
  "ZHIYUSHU",
  "DEFEND"
};
const std::map<int, const char*> _BuffType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kBuffTypeValues, _kBuffTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEffectTypeValues[] = {
  EffectType::EFFECT_ZHUO_SHAO
};
const char* _kEffectTypeNames[] = {
  "EFFECT_ZHUO_SHAO"
};
const std::map<int, const char*> _EffectType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kEffectTypeValues, _kEffectTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEUITypeValues[] = {
  EUIType::UI_JIEYI,
  EUIType::UI_JIEHUN,
  EUIType::UI_DANBAOJIN,
  EUIType::UI_QIANGHUA,
  EUIType::UI_HAHGHUI,
  EUIType::UI_PAIMAI,
  EUIType::UI_CANGKU,
  EUIType::UI_QIANZHUANG
};
const char* _kEUITypeNames[] = {
  "UI_JIEYI",
  "UI_JIEHUN",
  "UI_DANBAOJIN",
  "UI_QIANGHUA",
  "UI_HAHGHUI",
  "UI_PAIMAI",
  "UI_CANGKU",
  "UI_QIANZHUANG"
};
const std::map<int, const char*> _EUIType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kEUITypeValues, _kEUITypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMarriageHousePosValues[] = {
  MarriageHousePos::MARRY_HOUSE_POS_1,
  MarriageHousePos::MARRY_HOUSE_POS_2,
  MarriageHousePos::MARRY_HOUSE_POS_3,
  MarriageHousePos::MARRY_HOUSE_POS_4,
  MarriageHousePos::MARRY_HOUSE_POS_5,
  MarriageHousePos::MARRY_HOUSE_POS_6,
  MarriageHousePos::MARRY_HOUSE_POS_MAX
};
const char* _kMarriageHousePosNames[] = {
  "MARRY_HOUSE_POS_1",
  "MARRY_HOUSE_POS_2",
  "MARRY_HOUSE_POS_3",
  "MARRY_HOUSE_POS_4",
  "MARRY_HOUSE_POS_5",
  "MARRY_HOUSE_POS_6",
  "MARRY_HOUSE_POS_MAX"
};
const std::map<int, const char*> _MarriageHousePos_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMarriageHousePosValues, _kMarriageHousePosNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMarriageClientCmdValues[] = {
  MarriageClientCmd::MARRY_APPLY_TASK,
  MarriageClientCmd::MARRY_COMMIT_TASK,
  MarriageClientCmd::MARRY_SEND,
  MarriageClientCmd::MARRY_ATTEND_WEEDING,
  MarriageClientCmd::MARRY_NEW_LIST,
  MarriageClientCmd::MARRY_VISIT_HOUSE,
  MarriageClientCmd::MARRY_SET_HOUSE_ITEM,
  MarriageClientCmd::MARRY_LEARN_COUPLE_SKILL,
  MarriageClientCmd::MARRY_DIVORCE_NORMAL,
  MarriageClientCmd::MARRY_DIVORCE_FORCE,
  MarriageClientCmd::MARRY_QUERY_STATUS,
  MarriageClientCmd::MARRY_QUERY_ALL_MARRIAGE,
  MarriageClientCmd::MARRY_GIVEUP_TASK,
  MarriageClientCmd::MARRY_APPLY_WEDDING,
  MarriageClientCmd::MARRY_WEDDING_START,
  MarriageClientCmd::MARRY_DIVORCE_QUIT,
  MarriageClientCmd::MARRY_OFFLINE
};
const char* _kMarriageClientCmdNames[] = {
  "MARRY_APPLY_TASK",
  "MARRY_COMMIT_TASK",
  "MARRY_SEND",
  "MARRY_ATTEND_WEEDING",
  "MARRY_NEW_LIST",
  "MARRY_VISIT_HOUSE",
  "MARRY_SET_HOUSE_ITEM",
  "MARRY_LEARN_COUPLE_SKILL",
  "MARRY_DIVORCE_NORMAL",
  "MARRY_DIVORCE_FORCE",
  "MARRY_QUERY_STATUS",
  "MARRY_QUERY_ALL_MARRIAGE",
  "MARRY_GIVEUP_TASK",
  "MARRY_APPLY_WEDDING",
  "MARRY_WEDDING_START",
  "MARRY_DIVORCE_QUIT",
  "MARRY_OFFLINE"
};
const std::map<int, const char*> _MarriageClientCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(17, _kMarriageClientCmdValues, _kMarriageClientCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMarryStatusCmdValues[] = {
  MarryStatusCmd::MARRY_STATUS_NOT,
  MarryStatusCmd::MARRY_STATUS_TASK_GO,
  MarryStatusCmd::MARRY_STATUS_MARRIED,
  MarryStatusCmd::MARRY_STATUS_DIVORCING,
  MarryStatusCmd::MARRY_STATUS_TASK_FINISH
};
const char* _kMarryStatusCmdNames[] = {
  "MARRY_STATUS_NOT",
  "MARRY_STATUS_TASK_GO",
  "MARRY_STATUS_MARRIED",
  "MARRY_STATUS_DIVORCING",
  "MARRY_STATUS_TASK_FINISH"
};
const std::map<int, const char*> _MarryStatusCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kMarryStatusCmdValues, _kMarryStatusCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kWeddingFlagCmdValues[] = {
  WeddingFlagCmd::WEDDING_NOT_APPLY,
  WeddingFlagCmd::WEDDING_APPLYED,
  WeddingFlagCmd::WEDDING_FINISH,
  WeddingFlagCmd::WEDDING_FAIL
};
const char* _kWeddingFlagCmdNames[] = {
  "WEDDING_NOT_APPLY",
  "WEDDING_APPLYED",
  "WEDDING_FINISH",
  "WEDDING_FAIL"
};
const std::map<int, const char*> _WeddingFlagCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kWeddingFlagCmdValues, _kWeddingFlagCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMailMsgTypeValues[] = {
  MailMsgType::MAIL_MSG_FRIEND,
  MailMsgType::MAIL_MSG_GUILD,
  MailMsgType::MAIL_MSG_SYSTEM
};
const char* _kMailMsgTypeNames[] = {
  "MAIL_MSG_FRIEND",
  "MAIL_MSG_GUILD",
  "MAIL_MSG_SYSTEM"
};
const std::map<int, const char*> _MailMsgType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMailMsgTypeValues, _kMailMsgTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMailOpsCmdValues[] = {
  MailOpsCmd::MAIL_OP_ALL,
  MailOpsCmd::MAIL_OP_SEND,
  MailOpsCmd::MAIL_OP_DEL,
  MailOpsCmd::MAIL_OP_BACK,
  MailOpsCmd::MAIL_OP_TAKE_ATTACH,
  MailOpsCmd::MAIL_OP_GET_NEW,
  MailOpsCmd::MAIL_OP_MARK_READ
};
const char* _kMailOpsCmdNames[] = {
  "MAIL_OP_ALL",
  "MAIL_OP_SEND",
  "MAIL_OP_DEL",
  "MAIL_OP_BACK",
  "MAIL_OP_TAKE_ATTACH",
  "MAIL_OP_GET_NEW",
  "MAIL_OP_MARK_READ"
};
const std::map<int, const char*> _MailOpsCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMailOpsCmdValues, _kMailOpsCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMailStatusTypeValues[] = {
  MailStatusType::MAIL_STATUS_UNREAD,
  MailStatusType::MAIL_STATUS_READ,
  MailStatusType::MAIL_STATUS_BACKED
};
const char* _kMailStatusTypeNames[] = {
  "MAIL_STATUS_UNREAD",
  "MAIL_STATUS_READ",
  "MAIL_STATUS_BACKED"
};
const std::map<int, const char*> _MailStatusType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMailStatusTypeValues, _kMailStatusTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMailAttachTypeValues[] = {
  MailAttachType::MAIL_ATTACH_ITEM,
  MailAttachType::MAIL_ATTACH_EXP,
  MailAttachType::MAIL_ATTACH_GOLD
};
const char* _kMailAttachTypeNames[] = {
  "MAIL_ATTACH_ITEM",
  "MAIL_ATTACH_EXP",
  "MAIL_ATTACH_GOLD"
};
const std::map<int, const char*> _MailAttachType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kMailAttachTypeValues, _kMailAttachTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEATTACK_MODEValues[] = {
  EATTACK_MODE::PEACE,
  EATTACK_MODE::ALL_ATTACK,
  EATTACK_MODE::GUILD,
  EATTACK_MODE::TEAM
};
const char* _kEATTACK_MODENames[] = {
  "PEACE",
  "ALL_ATTACK",
  "GUILD",
  "TEAM"
};
const std::map<int, const char*> _EATTACK_MODE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kEATTACK_MODEValues, _kEATTACK_MODENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRankOpsCmdValues[] = {
  RankOpsCmd::GET_RANK_INFO
};
const char* _kRankOpsCmdNames[] = {
  "GET_RANK_INFO"
};
const std::map<int, const char*> _RankOpsCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kRankOpsCmdValues, _kRankOpsCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRankRefreshTypeValues[] = {
  RankRefreshType::NONE_VALUE,
  RankRefreshType::DAILY
};
const char* _kRankRefreshTypeNames[] = {
  "NONE_VALUE",
  "DAILY"
};
const std::map<int, const char*> _RankRefreshType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kRankRefreshTypeValues, _kRankRefreshTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRankTypeValues[] = {
  RankType::NONE_VALUE,
  RankType::FULL_FIGHTPOWER,
  RankType::LEVEL,
  RankType::GOLD,
  RankType::WUJIANG_FIGHTPOWER,
  RankType::CESHI_FIGHTPOWER,
  RankType::GONGJIAN_FIGHTPOWER,
  RankType::SHUSHI_FIGHTPOER,
  RankType::JUNTUAN_FIGHTPOWER,
  RankType::JUNTUAN_LEVEL,
  RankType::ZHANLING_COUNT,
  RankType::BROTHER_FIGHTPOWER,
  RankType::MARRY_FIGHTPOWER,
  RankType::MAX_VALUE
};
const char* _kRankTypeNames[] = {
  "NONE_VALUE",
  "FULL_FIGHTPOWER",
  "LEVEL",
  "GOLD",
  "WUJIANG_FIGHTPOWER",
  "CESHI_FIGHTPOWER",
  "GONGJIAN_FIGHTPOWER",
  "SHUSHI_FIGHTPOER",
  "JUNTUAN_FIGHTPOWER",
  "JUNTUAN_LEVEL",
  "ZHANLING_COUNT",
  "BROTHER_FIGHTPOWER",
  "MARRY_FIGHTPOWER",
  "MAX_VALUE"
};
const std::map<int, const char*> _RankType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(14, _kRankTypeValues, _kRankTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGuildWarOpsCmdValues[] = {
  GuildWarOpsCmd::APPLY_WAR,
  GuildWarOpsCmd::WAR_START,
  GuildWarOpsCmd::WAR_END,
  GuildWarOpsCmd::WAR_LIST,
  GuildWarOpsCmd::WAR_CANCEL_APPLY
};
const char* _kGuildWarOpsCmdNames[] = {
  "APPLY_WAR",
  "WAR_START",
  "WAR_END",
  "WAR_LIST",
  "WAR_CANCEL_APPLY"
};
const std::map<int, const char*> _GuildWarOpsCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kGuildWarOpsCmdValues, _kGuildWarOpsCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGuildCityWarOpsCmdValues[] = {
  GuildCityWarOpsCmd::APPLY_CITYWAR,
  GuildCityWarOpsCmd::CITYWAR_START,
  GuildCityWarOpsCmd::CITYWAR_END,
  GuildCityWarOpsCmd::CITYWAR_LIST,
  GuildCityWarOpsCmd::CITYWAR_INFO,
  GuildCityWarOpsCmd::CITYWAR_CANCEL
};
const char* _kGuildCityWarOpsCmdNames[] = {
  "APPLY_CITYWAR",
  "CITYWAR_START",
  "CITYWAR_END",
  "CITYWAR_LIST",
  "CITYWAR_INFO",
  "CITYWAR_CANCEL"
};
const std::map<int, const char*> _GuildCityWarOpsCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kGuildCityWarOpsCmdValues, _kGuildCityWarOpsCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDailyLoginRewardTypeValues[] = {
  DailyLoginRewardType::DAILY_REWARD_SEVEN,
  DailyLoginRewardType::DAILY_REWARD_ONLINE,
  DailyLoginRewardType::DAILY_REWARD_INVITE
};
const char* _kDailyLoginRewardTypeNames[] = {
  "DAILY_REWARD_SEVEN",
  "DAILY_REWARD_ONLINE",
  "DAILY_REWARD_INVITE"
};
const std::map<int, const char*> _DailyLoginRewardType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kDailyLoginRewardTypeValues, _kDailyLoginRewardTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDailyLoginOpsCmdValues[] = {
  DailyLoginOpsCmd::DAILY_OP_ALL_INFO,
  DailyLoginOpsCmd::DAILY_OP_SEVEN_REWARD,
  DailyLoginOpsCmd::DAILY_OP_ONLINE_REWARD,
  DailyLoginOpsCmd::DAILY_OP_INVITE_REWARD
};
const char* _kDailyLoginOpsCmdNames[] = {
  "DAILY_OP_ALL_INFO",
  "DAILY_OP_SEVEN_REWARD",
  "DAILY_OP_ONLINE_REWARD",
  "DAILY_OP_INVITE_REWARD"
};
const std::map<int, const char*> _DailyLoginOpsCmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kDailyLoginOpsCmdValues, _kDailyLoginOpsCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* GuildLevelOpsMsgReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t GuildLevelOpsMsgReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t GuildLevelOpsMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildLevelOpsMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildLevelOpsMsgReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildLevelOpsMsgReq &a, GuildLevelOpsMsgReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.gold, b.gold);
  swap(a.__isset, b.__isset);
}

const char* UserGuildInfoMsg::ascii_fingerprint = "2B9A2F494ACEFED4382427C582FDC550";
const uint8_t UserGuildInfoMsg::binary_fingerprint[16] = {0x2B,0x9A,0x2F,0x49,0x4A,0xCE,0xFE,0xD4,0x38,0x24,0x27,0xC5,0x82,0xFD,0xC5,0x50};

uint32_t UserGuildInfoMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->post);
          this->__isset.post = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->contribute);
          this->__isset.contribute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ranking);
          this->__isset.ranking = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserGuildInfoMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UserGuildInfoMsg");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("post", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->post);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("contribute", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->contribute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ranking", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->ranking);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserGuildInfoMsg &a, UserGuildInfoMsg &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.post, b.post);
  swap(a.contribute, b.contribute);
  swap(a.ranking, b.ranking);
  swap(a.level, b.level);
  swap(a.job, b.job);
  swap(a.__isset, b.__isset);
}

const char* GuildLevelOpsMsgRet::ascii_fingerprint = "CCE56901B2E7061CA1EAAFE39DEF629B";
const uint8_t GuildLevelOpsMsgRet::binary_fingerprint[16] = {0xCC,0xE5,0x69,0x01,0xB2,0xE7,0x06,0x1C,0xA1,0xEA,0xAF,0xE3,0x9D,0xEF,0x62,0x9B};

uint32_t GuildLevelOpsMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildLevel);
          this->__isset.guildLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ranking);
          this->__isset.ranking = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->guildMemberList.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->guildMemberList.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->guildMemberList[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.guildMemberList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildLevelOpsMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildLevelOpsMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildLevel", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->guildLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ranking", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->ranking);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildMemberList", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->guildMemberList.size()));
    std::vector<UserGuildInfoMsg> ::const_iterator _iter5;
    for (_iter5 = this->guildMemberList.begin(); _iter5 != this->guildMemberList.end(); ++_iter5)
    {
      xfer += (*_iter5).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildLevelOpsMsgRet &a, GuildLevelOpsMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.guildLevel, b.guildLevel);
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.gold, b.gold);
  swap(a.ranking, b.ranking);
  swap(a.guildMemberList, b.guildMemberList);
  swap(a.__isset, b.__isset);
}

const char* GuildInfoMsgReq::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t GuildInfoMsgReq::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t GuildInfoMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildImage);
          this->__isset.guildImage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildNotice);
          this->__isset.guildNotice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildInfoMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildInfoMsgReq");

  xfer += oprot->writeFieldBegin("guildImage", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->guildImage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildNotice", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guildNotice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildInfoMsgReq &a, GuildInfoMsgReq &b) {
  using ::std::swap;
  swap(a.guildImage, b.guildImage);
  swap(a.guildNotice, b.guildNotice);
  swap(a.__isset, b.__isset);
}

const char* GuildInfoOpsMsgRet::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t GuildInfoOpsMsgRet::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t GuildInfoOpsMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildImage);
          this->__isset.guildImage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildNotice);
          this->__isset.guildNotice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildInfoOpsMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildInfoOpsMsgRet");

  xfer += oprot->writeFieldBegin("guildImage", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->guildImage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildNotice", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guildNotice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildInfoOpsMsgRet &a, GuildInfoOpsMsgRet &b) {
  using ::std::swap;
  swap(a.guildImage, b.guildImage);
  swap(a.guildNotice, b.guildNotice);
  swap(a.__isset, b.__isset);
}

const char* GuildInfoMsg::ascii_fingerprint = "FF5BDB032217F31C09E1232FCFF60CE6";
const uint8_t GuildInfoMsg::binary_fingerprint[16] = {0xFF,0x5B,0xDB,0x03,0x22,0x17,0xF3,0x1C,0x09,0xE1,0x23,0x2F,0xCF,0xF6,0x0C,0xE6};

uint32_t GuildInfoMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildID);
          this->__isset.guildID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildName);
          this->__isset.guildName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildPlayerNumber);
          this->__isset.guildPlayerNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildLeaderName);
          this->__isset.guildLeaderName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildNotice);
          this->__isset.guildNotice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->levelRanking);
          this->__isset.levelRanking = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildImage);
          this->__isset.guildImage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildlevel);
          this->__isset.guildlevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildInfoMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildInfoMsg");

  xfer += oprot->writeFieldBegin("guildID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->guildID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guildName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildPlayerNumber", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->guildPlayerNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildLeaderName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->guildLeaderName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildNotice", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->guildNotice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelRanking", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->levelRanking);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildImage", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->guildImage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildlevel", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->guildlevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildInfoMsg &a, GuildInfoMsg &b) {
  using ::std::swap;
  swap(a.guildID, b.guildID);
  swap(a.guildName, b.guildName);
  swap(a.guildPlayerNumber, b.guildPlayerNumber);
  swap(a.guildLeaderName, b.guildLeaderName);
  swap(a.guildNotice, b.guildNotice);
  swap(a.levelRanking, b.levelRanking);
  swap(a.guildImage, b.guildImage);
  swap(a.guildlevel, b.guildlevel);
  swap(a.__isset, b.__isset);
}

const char* GuildInfoMsgRet::ascii_fingerprint = "06C7ED545C7323FD5436ED73447BA047";
const uint8_t GuildInfoMsgRet::binary_fingerprint[16] = {0x06,0xC7,0xED,0x54,0x5C,0x73,0x23,0xFD,0x54,0x36,0xED,0x73,0x44,0x7B,0xA0,0x47};

uint32_t GuildInfoMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allGuildInfo.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->allGuildInfo.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->allGuildInfo[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allGuildInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildInfoMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildInfoMsgRet");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allGuildInfo", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allGuildInfo.size()));
    std::vector<GuildInfoMsg> ::const_iterator _iter11;
    for (_iter11 = this->allGuildInfo.begin(); _iter11 != this->allGuildInfo.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildInfoMsgRet &a, GuildInfoMsgRet &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.allGuildInfo, b.allGuildInfo);
  swap(a.__isset, b.__isset);
}

const char* UserGuildListMsgRet::ascii_fingerprint = "DFDBDAE170185F596873DD396E092A90";
const uint8_t UserGuildListMsgRet::binary_fingerprint[16] = {0xDF,0xDB,0xDA,0xE1,0x70,0x18,0x5F,0x59,0x68,0x73,0xDD,0x39,0x6E,0x09,0x2A,0x90};

uint32_t UserGuildListMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildID);
          this->__isset.guildID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildName);
          this->__isset.guildName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildLevel);
          this->__isset.guildLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildImage);
          this->__isset.guildImage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildPlayerNumber);
          this->__isset.guildPlayerNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildMaxPlayerNumber);
          this->__isset.guildMaxPlayerNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildLeaderName);
          this->__isset.guildLeaderName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildNotice);
          this->__isset.guildNotice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildExp);
          this->__isset.guildExp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildUpdateExp);
          this->__isset.guildUpdateExp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->levelRanking);
          this->__isset.levelRanking = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->guildMemberList.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->guildMemberList.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->guildMemberList[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.guildMemberList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildPost);
          this->__isset.guildPost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dateContribution);
          this->__isset.dateContribution = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->maxContribution);
          this->__isset.maxContribution = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->guildMemberTempList.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->guildMemberTempList.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->guildMemberTempList[_i21].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.guildMemberTempList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->copymapEndTm);
          this->__isset.copymapEndTm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->typeCopyMap);
          this->__isset.typeCopyMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->warVsGuildInfo.read(iprot);
          this->__isset.warVsGuildInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tmWarStart);
          this->__isset.tmWarStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserGuildListMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UserGuildListMsgRet");

  xfer += oprot->writeFieldBegin("guildID", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->guildID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guildName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildLevel", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->guildLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildImage", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->guildImage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildPlayerNumber", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->guildPlayerNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildMaxPlayerNumber", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->guildMaxPlayerNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildLeaderName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->guildLeaderName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildNotice", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->guildNotice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildExp", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->guildExp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildUpdateExp", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->guildUpdateExp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelRanking", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->levelRanking);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildMemberList", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->guildMemberList.size()));
    std::vector<UserGuildInfoMsg> ::const_iterator _iter22;
    for (_iter22 = this->guildMemberList.begin(); _iter22 != this->guildMemberList.end(); ++_iter22)
    {
      xfer += (*_iter22).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildPost", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->guildPost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dateContribution", ::apache::thrift::protocol::T_I64, 14);
  xfer += oprot->writeI64(this->dateContribution);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxContribution", ::apache::thrift::protocol::T_I64, 15);
  xfer += oprot->writeI64(this->maxContribution);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildMemberTempList", ::apache::thrift::protocol::T_LIST, 16);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->guildMemberTempList.size()));
    std::vector<UserGuildInfoMsg> ::const_iterator _iter23;
    for (_iter23 = this->guildMemberTempList.begin(); _iter23 != this->guildMemberTempList.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copymapEndTm", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->copymapEndTm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeCopyMap", ::apache::thrift::protocol::T_I16, 18);
  xfer += oprot->writeI16(this->typeCopyMap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("warVsGuildInfo", ::apache::thrift::protocol::T_STRUCT, 19);
  xfer += this->warVsGuildInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tmWarStart", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->tmWarStart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserGuildListMsgRet &a, UserGuildListMsgRet &b) {
  using ::std::swap;
  swap(a.guildID, b.guildID);
  swap(a.guildName, b.guildName);
  swap(a.guildLevel, b.guildLevel);
  swap(a.guildImage, b.guildImage);
  swap(a.guildPlayerNumber, b.guildPlayerNumber);
  swap(a.guildMaxPlayerNumber, b.guildMaxPlayerNumber);
  swap(a.guildLeaderName, b.guildLeaderName);
  swap(a.guildNotice, b.guildNotice);
  swap(a.guildExp, b.guildExp);
  swap(a.guildUpdateExp, b.guildUpdateExp);
  swap(a.levelRanking, b.levelRanking);
  swap(a.guildMemberList, b.guildMemberList);
  swap(a.guildPost, b.guildPost);
  swap(a.dateContribution, b.dateContribution);
  swap(a.maxContribution, b.maxContribution);
  swap(a.guildMemberTempList, b.guildMemberTempList);
  swap(a.copymapEndTm, b.copymapEndTm);
  swap(a.typeCopyMap, b.typeCopyMap);
  swap(a.warVsGuildInfo, b.warVsGuildInfo);
  swap(a.tmWarStart, b.tmWarStart);
  swap(a.__isset, b.__isset);
}

const char* GuildMsgReq::ascii_fingerprint = "7D02F571D1258500DE15770C82B16F4A";
const uint8_t GuildMsgReq::binary_fingerprint[16] = {0x7D,0x02,0xF5,0x71,0xD1,0x25,0x85,0x00,0xDE,0x15,0x77,0x0C,0x82,0xB1,0x6F,0x4A};

uint32_t GuildMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildname);
          this->__isset.guildname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildid);
          this->__isset.guildid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->typeCopyMap);
          this->__isset.typeCopyMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildMsgReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildname", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->guildname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->guildid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeCopyMap", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->typeCopyMap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildMsgReq &a, GuildMsgReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.guildname, b.guildname);
  swap(a.guildid, b.guildid);
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.typeCopyMap, b.typeCopyMap);
  swap(a.__isset, b.__isset);
}

const char* GuildOpsMsgRet::ascii_fingerprint = "689A9B5349A90FE564EB1EC46E71E6AE";
const uint8_t GuildOpsMsgRet::binary_fingerprint[16] = {0x68,0x9A,0x9B,0x53,0x49,0xA9,0x0F,0xE5,0x64,0xEB,0x1E,0xC4,0x6E,0x71,0xE6,0xAE};

uint32_t GuildOpsMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildid);
          this->__isset.guildid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildname);
          this->__isset.guildname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->userid);
          this->__isset.userid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->guildMemberList.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->guildMemberList.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              xfer += this->guildMemberList[_i28].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.guildMemberList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->copymapEndTm);
          this->__isset.copymapEndTm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->typeCopyMap);
          this->__isset.typeCopyMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildOpsMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildOpsMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->guildid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildname", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->guildname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userid", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->userid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildMemberList", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->guildMemberList.size()));
    std::vector<UserGuildInfoMsg> ::const_iterator _iter29;
    for (_iter29 = this->guildMemberList.begin(); _iter29 != this->guildMemberList.end(); ++_iter29)
    {
      xfer += (*_iter29).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copymapEndTm", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->copymapEndTm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typeCopyMap", ::apache::thrift::protocol::T_I16, 8);
  xfer += oprot->writeI16(this->typeCopyMap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildOpsMsgRet &a, GuildOpsMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.guildid, b.guildid);
  swap(a.guildname, b.guildname);
  swap(a.userid, b.userid);
  swap(a.username, b.username);
  swap(a.guildMemberList, b.guildMemberList);
  swap(a.copymapEndTm, b.copymapEndTm);
  swap(a.typeCopyMap, b.typeCopyMap);
  swap(a.__isset, b.__isset);
}

const char* UpdateExpRet::ascii_fingerprint = "6435B39C87AB0E30F30BEDEFD7328C0D";
const uint8_t UpdateExpRet::binary_fingerprint[16] = {0x64,0x35,0xB3,0x9C,0x87,0xAB,0x0E,0x30,0xF3,0x0B,0xED,0xEF,0xD7,0x32,0x8C,0x0D};

uint32_t UpdateExpRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expMax);
          this->__isset.expMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateExpRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateExpRet");

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expMax", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->expMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateExpRet &a, UpdateExpRet &b) {
  using ::std::swap;
  swap(a.exp, b.exp);
  swap(a.level, b.level);
  swap(a.expMax, b.expMax);
  swap(a.__isset, b.__isset);
}

const char* UpdatePetExpRet::ascii_fingerprint = "2E8F302A6C4CB69C9302BBFE3E138479";
const uint8_t UpdatePetExpRet::binary_fingerprint[16] = {0x2E,0x8F,0x30,0x2A,0x6C,0x4C,0xB6,0x9C,0x93,0x02,0xBB,0xFE,0x3E,0x13,0x84,0x79};

uint32_t UpdatePetExpRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expMax);
          this->__isset.expMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdatePetExpRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdatePetExpRet");

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expMax", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->expMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdatePetExpRet &a, UpdatePetExpRet &b) {
  using ::std::swap;
  swap(a.exp, b.exp);
  swap(a.level, b.level);
  swap(a.expMax, b.expMax);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* LearnSkillReq::ascii_fingerprint = "C88FB7958D86460D03E699333A272947";
const uint8_t LearnSkillReq::binary_fingerprint[16] = {0xC8,0x8F,0xB7,0x95,0x8D,0x86,0x46,0x0D,0x03,0xE6,0x99,0x33,0x3A,0x27,0x29,0x47};

uint32_t LearnSkillReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->skillId);
          this->__isset.skillId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->skillLevel);
          this->__isset.skillLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LearnSkillReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LearnSkillReq");

  xfer += oprot->writeFieldBegin("skillId", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->skillId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillLevel", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->skillLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LearnSkillReq &a, LearnSkillReq &b) {
  using ::std::swap;
  swap(a.skillId, b.skillId);
  swap(a.skillLevel, b.skillLevel);
  swap(a.__isset, b.__isset);
}

const char* LearnSkillRet::ascii_fingerprint = "F5A017B2A1C387FD044C41CD46A76E4D";
const uint8_t LearnSkillRet::binary_fingerprint[16] = {0xF5,0xA0,0x17,0xB2,0xA1,0xC3,0x87,0xFD,0x04,0x4C,0x41,0xCD,0x46,0xA7,0x6E,0x4D};

uint32_t LearnSkillRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->skillId);
          this->__isset.skillId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->skillLevel);
          this->__isset.skillLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LearnSkillRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LearnSkillRet");

  xfer += oprot->writeFieldBegin("skillId", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->skillId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillLevel", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->skillLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LearnSkillRet &a, LearnSkillRet &b) {
  using ::std::swap;
  swap(a.skillId, b.skillId);
  swap(a.skillLevel, b.skillLevel);
  swap(a.exp, b.exp);
  swap(a.__isset, b.__isset);
}

const char* UseSkillReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t UseSkillReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t UseSkillReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->skillId);
          this->__isset.skillId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->targetId);
          this->__isset.targetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseSkillReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UseSkillReq");

  xfer += oprot->writeFieldBegin("skillId", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->skillId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->targetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseSkillReq &a, UseSkillReq &b) {
  using ::std::swap;
  swap(a.skillId, b.skillId);
  swap(a.targetId, b.targetId);
  swap(a.__isset, b.__isset);
}

const char* HPHurtRet::ascii_fingerprint = "A0B2AF69DE4621B7074F9A68E52A5ADC";
const uint8_t HPHurtRet::binary_fingerprint[16] = {0xA0,0xB2,0xAF,0x69,0xDE,0x46,0x21,0xB7,0x07,0x4F,0x9A,0x68,0xE5,0x2A,0x5A,0xDC};

uint32_t HPHurtRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->targetId);
          this->__isset.targetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->curHP);
          this->__isset.curHP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->curMP);
          this->__isset.curMP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hurtHP);
          this->__isset.hurtHP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->critFlag);
          this->__isset.critFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->hitFlag);
          this->__isset.hitFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->anger);
          this->__isset.anger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->angerMax);
          this->__isset.angerMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HPHurtRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HPHurtRet");

  xfer += oprot->writeFieldBegin("targetId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->targetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curHP", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->curHP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curMP", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->curMP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hurtHP", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->hurtHP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("critFlag", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->critFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hitFlag", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->hitFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("anger", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->anger);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angerMax", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->angerMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HPHurtRet &a, HPHurtRet &b) {
  using ::std::swap;
  swap(a.targetId, b.targetId);
  swap(a.curHP, b.curHP);
  swap(a.curMP, b.curMP);
  swap(a.hurtHP, b.hurtHP);
  swap(a.critFlag, b.critFlag);
  swap(a.hitFlag, b.hitFlag);
  swap(a.anger, b.anger);
  swap(a.angerMax, b.angerMax);
  swap(a.__isset, b.__isset);
}

const char* UseSkillRet::ascii_fingerprint = "962D67E7DD0DD0DD9EDEA0423A558AC8";
const uint8_t UseSkillRet::binary_fingerprint[16] = {0x96,0x2D,0x67,0xE7,0xDD,0x0D,0xD0,0xDD,0x9E,0xDE,0xA0,0x42,0x3A,0x55,0x8A,0xC8};

uint32_t UseSkillRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->skillId);
          this->__isset.skillId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->targetId);
          this->__isset.targetId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nextCDMs);
          this->__isset.nextCDMs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->curHP);
          this->__isset.curHP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->curMP);
          this->__isset.curMP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->anger);
          this->__isset.anger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->angerMax);
          this->__isset.angerMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetX);
          this->__isset.targetX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->targetY);
          this->__isset.targetY = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseSkillRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UseSkillRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillId", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->skillId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->targetId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nextCDMs", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->nextCDMs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curHP", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->curHP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curMP", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->curMP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("anger", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->anger);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angerMax", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->angerMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetX", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->targetX);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetY", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->targetY);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseSkillRet &a, UseSkillRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.skillId, b.skillId);
  swap(a.targetId, b.targetId);
  swap(a.nextCDMs, b.nextCDMs);
  swap(a.curHP, b.curHP);
  swap(a.curMP, b.curMP);
  swap(a.anger, b.anger);
  swap(a.angerMax, b.angerMax);
  swap(a.targetX, b.targetX);
  swap(a.targetY, b.targetY);
  swap(a.__isset, b.__isset);
}

const char* SyncHpMpRet::ascii_fingerprint = "9C4E30169AD9E0914633984FE5C16314";
const uint8_t SyncHpMpRet::binary_fingerprint[16] = {0x9C,0x4E,0x30,0x16,0x9A,0xD9,0xE0,0x91,0x46,0x33,0x98,0x4F,0xE5,0xC1,0x63,0x14};

uint32_t SyncHpMpRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->curHP);
          this->__isset.curHP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->curMP);
          this->__isset.curMP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SyncHpMpRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SyncHpMpRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curHP", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->curHP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curMP", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->curMP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SyncHpMpRet &a, SyncHpMpRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.curHP, b.curHP);
  swap(a.curMP, b.curMP);
  swap(a.__isset, b.__isset);
}

const char* Task::ascii_fingerprint = "0EE64969ED2BF14C121C42E26F3D1415";
const uint8_t Task::binary_fingerprint[16] = {0x0E,0xE6,0x49,0x69,0xED,0x2B,0xF1,0x4C,0x12,0x1C,0x42,0xE2,0x6F,0x3D,0x14,0x15};

uint32_t Task::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->taskId);
          this->__isset.taskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->taskType);
          this->__isset.taskType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->action);
          this->__isset.action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->object);
          this->__isset.object = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->destValue);
          this->__isset.destValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetDesc);
          this->__isset.targetDesc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->acceptnpc);
          this->__isset.acceptnpc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->finishnpc);
          this->__isset.finishnpc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->needlevel);
          this->__isset.needlevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Task::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Task");

  xfer += oprot->writeFieldBegin("taskId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->taskId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskType", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->taskType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("action", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->action);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("object", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->object);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destValue", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->destValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetDesc", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->targetDesc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acceptnpc", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->acceptnpc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("finishnpc", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->finishnpc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("needlevel", ::apache::thrift::protocol::T_I16, 12);
  xfer += oprot->writeI16(this->needlevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Task &a, Task &b) {
  using ::std::swap;
  swap(a.taskId, b.taskId);
  swap(a.taskType, b.taskType);
  swap(a.status, b.status);
  swap(a.action, b.action);
  swap(a.object, b.object);
  swap(a.value, b.value);
  swap(a.destValue, b.destValue);
  swap(a.name, b.name);
  swap(a.targetDesc, b.targetDesc);
  swap(a.acceptnpc, b.acceptnpc);
  swap(a.finishnpc, b.finishnpc);
  swap(a.needlevel, b.needlevel);
  swap(a.gold, b.gold);
  swap(a.exp, b.exp);
  swap(a.__isset, b.__isset);
}

const char* TaskListRet::ascii_fingerprint = "83654BF541D6EE16CA53289F7B80FBF0";
const uint8_t TaskListRet::binary_fingerprint[16] = {0x83,0x65,0x4B,0xF5,0x41,0xD6,0xEE,0x16,0xCA,0x53,0x28,0x9F,0x7B,0x80,0xFB,0xF0};

uint32_t TaskListRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allTask.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->allTask.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += this->allTask[_i34].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allTask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TaskListRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TaskListRet");

  xfer += oprot->writeFieldBegin("allTask", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allTask.size()));
    std::vector<Task> ::const_iterator _iter35;
    for (_iter35 = this->allTask.begin(); _iter35 != this->allTask.end(); ++_iter35)
    {
      xfer += (*_iter35).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TaskListRet &a, TaskListRet &b) {
  using ::std::swap;
  swap(a.allTask, b.allTask);
  swap(a.__isset, b.__isset);
}

const char* UpdateTaskStatusReq::ascii_fingerprint = "422C35A5D98C69C9CDE50568C7E3028F";
const uint8_t UpdateTaskStatusReq::binary_fingerprint[16] = {0x42,0x2C,0x35,0xA5,0xD9,0x8C,0x69,0xC9,0xCD,0xE5,0x05,0x68,0xC7,0xE3,0x02,0x8F};

uint32_t UpdateTaskStatusReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->taskId);
          this->__isset.taskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateTaskStatusReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateTaskStatusReq");

  xfer += oprot->writeFieldBegin("taskId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->taskId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateTaskStatusReq &a, UpdateTaskStatusReq &b) {
  using ::std::swap;
  swap(a.taskId, b.taskId);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* UpdateTaskStatusRet::ascii_fingerprint = "B24DE5D9A110C3C5A79025B9C0FDBD21";
const uint8_t UpdateTaskStatusRet::binary_fingerprint[16] = {0xB2,0x4D,0xE5,0xD9,0xA1,0x10,0xC3,0xC5,0xA7,0x90,0x25,0xB9,0xC0,0xFD,0xBD,0x21};

uint32_t UpdateTaskStatusRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->taskId);
          this->__isset.taskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nextTask.read(iprot);
          this->__isset.nextTask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateTaskStatusRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateTaskStatusRet");

  xfer += oprot->writeFieldBegin("taskId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->taskId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.nextTask) {
    xfer += oprot->writeFieldBegin("nextTask", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->nextTask.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateTaskStatusRet &a, UpdateTaskStatusRet &b) {
  using ::std::swap;
  swap(a.taskId, b.taskId);
  swap(a.status, b.status);
  swap(a.value, b.value);
  swap(a.nextTask, b.nextTask);
  swap(a.__isset, b.__isset);
}

const char* ShowTaskPanelRet::ascii_fingerprint = "BA72B6C8158F302EDC12272F88063DFF";
const uint8_t ShowTaskPanelRet::binary_fingerprint[16] = {0xBA,0x72,0xB6,0xC8,0x15,0x8F,0x30,0x2E,0xDC,0x12,0x27,0x2F,0x88,0x06,0x3D,0xFF};

uint32_t ShowTaskPanelRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->showType);
          this->__isset.showType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->taskId);
          this->__isset.taskId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->callbackId);
          this->__isset.callbackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowTaskPanelRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ShowTaskPanelRet");

  xfer += oprot->writeFieldBegin("showType", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->showType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("taskId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->taskId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("callbackId", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->callbackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowTaskPanelRet &a, ShowTaskPanelRet &b) {
  using ::std::swap;
  swap(a.showType, b.showType);
  swap(a.taskId, b.taskId);
  swap(a.content, b.content);
  swap(a.callbackId, b.callbackId);
  swap(a.__isset, b.__isset);
}

const char* ServerCallBackReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t ServerCallBackReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t ServerCallBackReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->callbackId);
          this->__isset.callbackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServerCallBackReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ServerCallBackReq");

  xfer += oprot->writeFieldBegin("callbackId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->callbackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServerCallBackReq &a, ServerCallBackReq &b) {
  using ::std::swap;
  swap(a.callbackId, b.callbackId);
  swap(a.__isset, b.__isset);
}

const char* Skill::ascii_fingerprint = "A05247FB9447183473173A5964AB3CFD";
const uint8_t Skill::binary_fingerprint[16] = {0xA0,0x52,0x47,0xFB,0x94,0x47,0x18,0x34,0x73,0x17,0x3A,0x59,0x64,0xAB,0x3C,0xFD};

uint32_t Skill::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->skillId);
          this->__isset.skillId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->skillLevel);
          this->__isset.skillLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastUsedTM);
          this->__isset.lastUsedTM = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->cd);
          this->__isset.cd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Skill::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Skill");

  xfer += oprot->writeFieldBegin("skillId", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->skillId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("skillLevel", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->skillLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastUsedTM", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->lastUsedTM);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cd", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->cd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->position);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Skill &a, Skill &b) {
  using ::std::swap;
  swap(a.skillId, b.skillId);
  swap(a.skillLevel, b.skillLevel);
  swap(a.lastUsedTM, b.lastUsedTM);
  swap(a.cd, b.cd);
  swap(a.position, b.position);
  swap(a.exp, b.exp);
  swap(a.__isset, b.__isset);
}

const char* EquipOpsReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t EquipOpsReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t EquipOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EquipOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EquipOpsReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EquipOpsReq &a, EquipOpsReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* EquipItemRet::ascii_fingerprint = "9763B9D124C8339490EA9AA9EB582188";
const uint8_t EquipItemRet::binary_fingerprint[16] = {0x97,0x63,0xB9,0xD1,0x24,0xC8,0x33,0x94,0x90,0xEA,0x9A,0xA9,0xEB,0x58,0x21,0x88};

uint32_t EquipItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->itemIdEquip);
          this->__isset.itemIdEquip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->itemIdUnEquip);
          this->__isset.itemIdUnEquip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemIdUnEquipPos);
          this->__isset.itemIdUnEquipPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EquipItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EquipItemRet");

  xfer += oprot->writeFieldBegin("itemIdEquip", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->itemIdEquip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemIdUnEquip", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->itemIdUnEquip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemIdUnEquipPos", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->itemIdUnEquipPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EquipItemRet &a, EquipItemRet &b) {
  using ::std::swap;
  swap(a.itemIdEquip, b.itemIdEquip);
  swap(a.itemIdUnEquip, b.itemIdUnEquip);
  swap(a.itemIdUnEquipPos, b.itemIdUnEquipPos);
  swap(a.__isset, b.__isset);
}

const char* UnEquipItemRet::ascii_fingerprint = "40A18C122C27341992EBAD8856A14D0D";
const uint8_t UnEquipItemRet::binary_fingerprint[16] = {0x40,0xA1,0x8C,0x12,0x2C,0x27,0x34,0x19,0x92,0xEB,0xAD,0x88,0x56,0xA1,0x4D,0x0D};

uint32_t UnEquipItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->itemIdUnEquip);
          this->__isset.itemIdUnEquip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemIdUnEquipPos);
          this->__isset.itemIdUnEquipPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnEquipItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UnEquipItemRet");

  xfer += oprot->writeFieldBegin("itemIdUnEquip", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->itemIdUnEquip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemIdUnEquipPos", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->itemIdUnEquipPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnEquipItemRet &a, UnEquipItemRet &b) {
  using ::std::swap;
  swap(a.itemIdUnEquip, b.itemIdUnEquip);
  swap(a.itemIdUnEquipPos, b.itemIdUnEquipPos);
  swap(a.__isset, b.__isset);
}

const char* ThrowItemRet::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t ThrowItemRet::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t ThrowItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThrowItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ThrowItemRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThrowItemRet &a, ThrowItemRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* UseItemReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t UseItemReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t UseItemReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseItemReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UseItemReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseItemReq &a, UseItemReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* UseItemRet::ascii_fingerprint = "AFAFBCDB9822F9D1AA4E44188E720B47";
const uint8_t UseItemRet::binary_fingerprint[16] = {0xAF,0xAF,0xBC,0xDB,0x98,0x22,0xF9,0xD1,0xAA,0x4E,0x44,0x18,0x8E,0x72,0x0B,0x47};

uint32_t UseItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leftTimes);
          this->__isset.leftTimes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UseItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UseItemRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leftTimes", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->leftTimes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UseItemRet &a, UseItemRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.leftTimes, b.leftTimes);
  swap(a.__isset, b.__isset);
}

const char* DieJiaItemReq::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t DieJiaItemReq::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t DieJiaItemReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidFrom);
          this->__isset.uidFrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidTo);
          this->__isset.uidTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DieJiaItemReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DieJiaItemReq");

  xfer += oprot->writeFieldBegin("uidFrom", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uidFrom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uidTo", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uidTo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DieJiaItemReq &a, DieJiaItemReq &b) {
  using ::std::swap;
  swap(a.uidFrom, b.uidFrom);
  swap(a.uidTo, b.uidTo);
  swap(a.__isset, b.__isset);
}

const char* DieJiaItemRet::ascii_fingerprint = "9763B9D124C8339490EA9AA9EB582188";
const uint8_t DieJiaItemRet::binary_fingerprint[16] = {0x97,0x63,0xB9,0xD1,0x24,0xC8,0x33,0x94,0x90,0xEA,0x9A,0xA9,0xEB,0x58,0x21,0x88};

uint32_t DieJiaItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidFrom);
          this->__isset.uidFrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidTo);
          this->__isset.uidTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leftTimes);
          this->__isset.leftTimes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DieJiaItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DieJiaItemRet");

  xfer += oprot->writeFieldBegin("uidFrom", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uidFrom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uidTo", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uidTo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leftTimes", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->leftTimes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DieJiaItemRet &a, DieJiaItemRet &b) {
  using ::std::swap;
  swap(a.uidFrom, b.uidFrom);
  swap(a.uidTo, b.uidTo);
  swap(a.leftTimes, b.leftTimes);
  swap(a.__isset, b.__isset);
}

const char* QuerySkillRet::ascii_fingerprint = "6F438A5DEDD8A25EEF21BD166D10A135";
const uint8_t QuerySkillRet::binary_fingerprint[16] = {0x6F,0x43,0x8A,0x5D,0xED,0xD8,0xA2,0x5E,0xEF,0x21,0xBD,0x16,0x6D,0x10,0xA1,0x35};

uint32_t QuerySkillRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allSkill.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->allSkill.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->allSkill[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allSkill = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QuerySkillRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QuerySkillRet");

  xfer += oprot->writeFieldBegin("allSkill", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allSkill.size()));
    std::vector<Skill> ::const_iterator _iter41;
    for (_iter41 = this->allSkill.begin(); _iter41 != this->allSkill.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QuerySkillRet &a, QuerySkillRet &b) {
  using ::std::swap;
  swap(a.allSkill, b.allSkill);
  swap(a.__isset, b.__isset);
}

const char* Item::ascii_fingerprint = "E75319F358A1ED299DFFCB53FE720D74";
const uint8_t Item::binary_fingerprint[16] = {0xE7,0x53,0x19,0xF3,0x58,0xA1,0xED,0x29,0x9D,0xFF,0xCB,0x53,0xFE,0x72,0x0D,0x74};

uint32_t Item::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemCfgId);
          this->__isset.itemCfgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->strengthenLevel);
          this->__isset.strengthenLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lefttimes);
          this->__isset.lefttimes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->propExt.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _ktype43;
            ::apache::thrift::protocol::TType _vtype44;
            xfer += iprot->readMapBegin(_ktype43, _vtype44, _size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              int32_t _key47;
              xfer += iprot->readI32(_key47);
              int32_t& _val48 = this->propExt[_key47];
              xfer += iprot->readI32(_val48);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.propExt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->propStrengthen.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _ktype50;
            ::apache::thrift::protocol::TType _vtype51;
            xfer += iprot->readMapBegin(_ktype50, _vtype51, _size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              int32_t _key54;
              xfer += iprot->readI32(_key54);
              int32_t& _val55 = this->propStrengthen[_key54];
              xfer += iprot->readI32(_val55);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.propStrengthen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Item::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Item");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemCfgId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->itemCfgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strengthenLevel", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->strengthenLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lefttimes", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->lefttimes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propExt", ::apache::thrift::protocol::T_MAP, 6);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->propExt.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter56;
    for (_iter56 = this->propExt.begin(); _iter56 != this->propExt.end(); ++_iter56)
    {
      xfer += oprot->writeI32(_iter56->first);
      xfer += oprot->writeI32(_iter56->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propStrengthen", ::apache::thrift::protocol::T_MAP, 7);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->propStrengthen.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter57;
    for (_iter57 = this->propStrengthen.begin(); _iter57 != this->propStrengthen.end(); ++_iter57)
    {
      xfer += oprot->writeI32(_iter57->first);
      xfer += oprot->writeI32(_iter57->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Item &a, Item &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.itemCfgId, b.itemCfgId);
  swap(a.name, b.name);
  swap(a.strengthenLevel, b.strengthenLevel);
  swap(a.lefttimes, b.lefttimes);
  swap(a.propExt, b.propExt);
  swap(a.propStrengthen, b.propStrengthen);
  swap(a.__isset, b.__isset);
}

const char* PickUpItemReq::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t PickUpItemReq::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t PickUpItemReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PickUpItemReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PickUpItemReq");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PickUpItemReq &a, PickUpItemReq &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

const char* PickUpItemRet::ascii_fingerprint = "3BD0055DD7A62399F8D555C6483834B2";
const uint8_t PickUpItemRet::binary_fingerprint[16] = {0x3B,0xD0,0x05,0x5D,0xD7,0xA6,0x23,0x99,0xF8,0xD5,0x55,0xC6,0x48,0x38,0x34,0xB2};

uint32_t PickUpItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->item.read(iprot);
          this->__isset.item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PickUpItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PickUpItemRet");

  xfer += oprot->writeFieldBegin("item", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PickUpItemRet &a, PickUpItemRet &b) {
  using ::std::swap;
  swap(a.item, b.item);
  swap(a.__isset, b.__isset);
}

const char* StrengthenItemReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t StrengthenItemReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t StrengthenItemReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StrengthenItemReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StrengthenItemReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StrengthenItemReq &a, StrengthenItemReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* StrengthenItemRet::ascii_fingerprint = "921B88838835290239CF997C2A98CC32";
const uint8_t StrengthenItemRet::binary_fingerprint[16] = {0x92,0x1B,0x88,0x83,0x88,0x35,0x29,0x02,0x39,0xCF,0x99,0x7C,0x2A,0x98,0xCC,0x32};

uint32_t StrengthenItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->propAdded.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _ktype59;
            ::apache::thrift::protocol::TType _vtype60;
            xfer += iprot->readMapBegin(_ktype59, _vtype60, _size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              int32_t _key63;
              xfer += iprot->readI32(_key63);
              int32_t& _val64 = this->propAdded[_key63];
              xfer += iprot->readI32(_val64);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.propAdded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StrengthenItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StrengthenItemRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propAdded", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->propAdded.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter65;
    for (_iter65 = this->propAdded.begin(); _iter65 != this->propAdded.end(); ++_iter65)
    {
      xfer += oprot->writeI32(_iter65->first);
      xfer += oprot->writeI32(_iter65->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StrengthenItemRet &a, StrengthenItemRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.level, b.level);
  swap(a.propAdded, b.propAdded);
  swap(a.__isset, b.__isset);
}

const char* QueryPkgRet::ascii_fingerprint = "65C3B09FF4D79497A807DC63190C7FBF";
const uint8_t QueryPkgRet::binary_fingerprint[16] = {0x65,0xC3,0xB0,0x9F,0xF4,0xD7,0x94,0x97,0xA8,0x07,0xDC,0x63,0x19,0x0C,0x7F,0xBF};

uint32_t QueryPkgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->allItem.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _ktype67;
            ::apache::thrift::protocol::TType _vtype68;
            xfer += iprot->readMapBegin(_ktype67, _vtype68, _size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              int16_t _key71;
              xfer += iprot->readI16(_key71);
              Item& _val72 = this->allItem[_key71];
              xfer += _val72.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.allItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pkgMaxSize);
          this->__isset.pkgMaxSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QueryPkgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QueryPkgRet");

  xfer += oprot->writeFieldBegin("allItem", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allItem.size()));
    std::map<int16_t, Item> ::const_iterator _iter73;
    for (_iter73 = this->allItem.begin(); _iter73 != this->allItem.end(); ++_iter73)
    {
      xfer += oprot->writeI16(_iter73->first);
      xfer += _iter73->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pkgMaxSize", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->pkgMaxSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryPkgRet &a, QueryPkgRet &b) {
  using ::std::swap;
  swap(a.allItem, b.allItem);
  swap(a.pkgMaxSize, b.pkgMaxSize);
  swap(a.__isset, b.__isset);
}

const char* QueryEquipReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t QueryEquipReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t QueryEquipReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QueryEquipReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QueryEquipReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryEquipReq &a, QueryEquipReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* QueryEquipRet::ascii_fingerprint = "D56327464FEC297EF7E0CB59AB38D5DF";
const uint8_t QueryEquipRet::binary_fingerprint[16] = {0xD5,0x63,0x27,0x46,0x4F,0xEC,0x29,0x7E,0xF7,0xE0,0xCB,0x59,0xAB,0x38,0xD5,0xDF};

uint32_t QueryEquipRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->allItem.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _ktype75;
            ::apache::thrift::protocol::TType _vtype76;
            xfer += iprot->readMapBegin(_ktype75, _vtype76, _size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              int16_t _key79;
              xfer += iprot->readI16(_key79);
              Item& _val80 = this->allItem[_key79];
              xfer += _val80.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.allItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QueryEquipRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QueryEquipRet");

  xfer += oprot->writeFieldBegin("allItem", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allItem.size()));
    std::map<int16_t, Item> ::const_iterator _iter81;
    for (_iter81 = this->allItem.begin(); _iter81 != this->allItem.end(); ++_iter81)
    {
      xfer += oprot->writeI16(_iter81->first);
      xfer += _iter81->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QueryEquipRet &a, QueryEquipRet &b) {
  using ::std::swap;
  swap(a.allItem, b.allItem);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* ItemEnterMapRet::ascii_fingerprint = "BE3A22B351B833B7BB1F7D4167460373";
const uint8_t ItemEnterMapRet::binary_fingerprint[16] = {0xBE,0x3A,0x22,0xB3,0x51,0xB8,0x33,0xB7,0xBB,0x1F,0x7D,0x41,0x67,0x46,0x03,0x73};

uint32_t ItemEnterMapRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemCfgId);
          this->__isset.itemCfgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemEnterMapRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ItemEnterMapRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemCfgId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->itemCfgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemEnterMapRet &a, ItemEnterMapRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.itemCfgId, b.itemCfgId);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

const char* EmptyReq::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t EmptyReq::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t EmptyReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EmptyReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EmptyReq");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EmptyReq &a, EmptyReq &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* LoginReq::ascii_fingerprint = "4F67BDE0243EB952250A3E0F0BD5255C";
const uint8_t LoginReq::binary_fingerprint[16] = {0x4F,0x67,0xBD,0xE0,0x24,0x3E,0xB9,0x52,0x25,0x0A,0x3E,0x0F,0x0B,0xD5,0x25,0x5C};

uint32_t LoginReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->reconnectUid);
          this->__isset.reconnectUid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LoginReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LoginReq");

  xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->username);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reconnectUid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->reconnectUid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LoginReq &a, LoginReq &b) {
  using ::std::swap;
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.reconnectUid, b.reconnectUid);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

const char* ReLoginRet::ascii_fingerprint = "99914B932BD37A50B983C5E7C90AE93B";
const uint8_t ReLoginRet::binary_fingerprint[16] = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

uint32_t ReLoginRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReLoginRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ReLoginRet");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReLoginRet &a, ReLoginRet &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

const char* RoleInfo::ascii_fingerprint = "074F0879BCB2A136A2BA27BB33E41851";
const uint8_t RoleInfo::binary_fingerprint[16] = {0x07,0x4F,0x08,0x79,0xBC,0xB2,0xA1,0x36,0xA2,0xBA,0x27,0xBB,0x33,0xE4,0x18,0x51};

uint32_t RoleInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RoleInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RoleInfo");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RoleInfo &a, RoleInfo &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.exp, b.exp);
  swap(a.__isset, b.__isset);
}

const char* UserInfoRet::ascii_fingerprint = "4D5EE8B8E5EDB1BCB57367FAF74FB03F";
const uint8_t UserInfoRet::binary_fingerprint[16] = {0x4D,0x5E,0xE8,0xB8,0xE5,0xED,0xB1,0xBC,0xB5,0x73,0x67,0xFA,0xF7,0x4F,0xB0,0x3F};

uint32_t UserInfoRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->timeServer);
          this->__isset.timeServer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listRole.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->listRole.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += this->listRole[_i86].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserInfoRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UserInfoRet");

  xfer += oprot->writeFieldBegin("timeServer", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->timeServer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listRole", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listRole.size()));
    std::vector<RoleInfo> ::const_iterator _iter87;
    for (_iter87 = this->listRole.begin(); _iter87 != this->listRole.end(); ++_iter87)
    {
      xfer += (*_iter87).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserInfoRet &a, UserInfoRet &b) {
  using ::std::swap;
  swap(a.timeServer, b.timeServer);
  swap(a.listRole, b.listRole);
  swap(a.__isset, b.__isset);
}

const char* CreateRoleReq::ascii_fingerprint = "5D4CB0B6C71DED11DCD9C5F223C09E75";
const uint8_t CreateRoleReq::binary_fingerprint[16] = {0x5D,0x4C,0xB0,0xB6,0xC7,0x1D,0xED,0x11,0xDC,0xD9,0xC5,0xF2,0x23,0xC0,0x9E,0x75};

uint32_t CreateRoleReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateRoleReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CreateRoleReq");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateRoleReq &a, CreateRoleReq &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.__isset, b.__isset);
}

const char* CreateRoleRet::ascii_fingerprint = "9B4734760796DF78842BE19FAACF382A";
const uint8_t CreateRoleRet::binary_fingerprint[16] = {0x9B,0x47,0x34,0x76,0x07,0x96,0xDF,0x78,0x84,0x2B,0xE1,0x9F,0xAA,0xCF,0x38,0x2A};

uint32_t CreateRoleRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->flag);
          this->__isset.flag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errMsg);
          this->__isset.errMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateRoleRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CreateRoleRet");

  xfer += oprot->writeFieldBegin("flag", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->flag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errMsg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->errMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateRoleRet &a, CreateRoleRet &b) {
  using ::std::swap;
  swap(a.flag, b.flag);
  swap(a.errMsg, b.errMsg);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* SelectRoleReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t SelectRoleReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t SelectRoleReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SelectRoleReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SelectRoleReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SelectRoleReq &a, SelectRoleReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* DelRoleReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t DelRoleReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t DelRoleReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DelRoleReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DelRoleReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DelRoleReq &a, DelRoleReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* DelRoleRet::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t DelRoleRet::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t DelRoleRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DelRoleRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DelRoleRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DelRoleRet &a, DelRoleRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* RandNameReq::ascii_fingerprint = "565787C31CF2D774B532CB755189BF39";
const uint8_t RandNameReq::binary_fingerprint[16] = {0x56,0x57,0x87,0xC3,0x1C,0xF2,0xD7,0x74,0xB5,0x32,0xCB,0x75,0x51,0x89,0xBF,0x39};

uint32_t RandNameReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RandNameReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RandNameReq");

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RandNameReq &a, RandNameReq &b) {
  using ::std::swap;
  swap(a.gender, b.gender);
  swap(a.__isset, b.__isset);
}

const char* RandNameRet::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t RandNameRet::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t RandNameRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RandNameRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RandNameRet");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RandNameRet &a, RandNameRet &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

const char* PlayerInfoRet::ascii_fingerprint = "48AD1125CE00AF13EF105730DCE00AE9";
const uint8_t PlayerInfoRet::binary_fingerprint[16] = {0x48,0xAD,0x11,0x25,0xCE,0x00,0xAF,0x13,0xEF,0x10,0x57,0x30,0xDC,0xE0,0x0A,0xE9};

uint32_t PlayerInfoRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mapname);
          this->__isset.mapname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->direction);
          this->__isset.direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hp);
          this->__isset.hp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hpMax);
          this->__isset.hpMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mp);
          this->__isset.mp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mpMax);
          this->__isset.mpMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expMax);
          this->__isset.expMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->pkSinValue);
          this->__isset.pkSinValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->color);
          this->__isset.color = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->xiongJiaCfgId);
          this->__isset.xiongJiaCfgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerInfoRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PlayerInfoRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapname", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->mapname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_I16, 9);
  xfer += oprot->writeI16(this->direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hp", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->hp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hpMax", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->hpMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mp", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->mp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mpMax", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->mpMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expMax", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->expMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pkSinValue", ::apache::thrift::protocol::T_I16, 17);
  xfer += oprot->writeI16(this->pkSinValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("color", ::apache::thrift::protocol::T_I16, 18);
  xfer += oprot->writeI16(this->color);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xiongJiaCfgId", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->xiongJiaCfgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerInfoRet &a, PlayerInfoRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.mapname, b.mapname);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.level, b.level);
  swap(a.direction, b.direction);
  swap(a.hp, b.hp);
  swap(a.hpMax, b.hpMax);
  swap(a.mp, b.mp);
  swap(a.mpMax, b.mpMax);
  swap(a.exp, b.exp);
  swap(a.expMax, b.expMax);
  swap(a.pkSinValue, b.pkSinValue);
  swap(a.color, b.color);
  swap(a.xiongJiaCfgId, b.xiongJiaCfgId);
  swap(a.__isset, b.__isset);
}

const char* PlayerPropRet::ascii_fingerprint = "90D022C7E43A4167C266CE50082AF205";
const uint8_t PlayerPropRet::binary_fingerprint[16] = {0x90,0xD0,0x22,0xC7,0xE4,0x3A,0x41,0x67,0xC2,0x66,0xCE,0x50,0x08,0x2A,0xF2,0x05};

uint32_t PlayerPropRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->baseInfo.read(iprot);
          this->__isset.baseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physicAttackMin);
          this->__isset.physicAttackMin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physicAttackMax);
          this->__isset.physicAttackMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->magicAttackMin);
          this->__isset.magicAttackMin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->magicAttackMax);
          this->__isset.magicAttackMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physicDefendMin);
          this->__isset.physicDefendMin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->physicDefendMax);
          this->__isset.physicDefendMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->magicDefendMin);
          this->__isset.magicDefendMin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->magicDefendMax);
          this->__isset.magicDefendMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->crit);
          this->__isset.crit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->hit);
          this->__isset.hit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->avoid);
          this->__isset.avoid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->attackSpeed);
          this->__isset.attackSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->attackSing);
          this->__isset.attackSing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->attackInterval);
          this->__isset.attackInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->attackDistance);
          this->__isset.attackDistance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->moveSpeed);
          this->__isset.moveSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->hurtAbsorb);
          this->__isset.hurtAbsorb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->hpAbsorb);
          this->__isset.hpAbsorb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fightPower);
          this->__isset.fightPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->anger);
          this->__isset.anger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->angerMax);
          this->__isset.angerMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerPropRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PlayerPropRet");

  xfer += oprot->writeFieldBegin("baseInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->baseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("physicAttackMin", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->physicAttackMin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("physicAttackMax", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->physicAttackMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("magicAttackMin", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->magicAttackMin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("magicAttackMax", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->magicAttackMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("physicDefendMin", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->physicDefendMin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("physicDefendMax", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->physicDefendMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("magicDefendMin", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->magicDefendMin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("magicDefendMax", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->magicDefendMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("crit", ::apache::thrift::protocol::T_I16, 11);
  xfer += oprot->writeI16(this->crit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hit", ::apache::thrift::protocol::T_I16, 12);
  xfer += oprot->writeI16(this->hit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("avoid", ::apache::thrift::protocol::T_I16, 13);
  xfer += oprot->writeI16(this->avoid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackSpeed", ::apache::thrift::protocol::T_I16, 14);
  xfer += oprot->writeI16(this->attackSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackSing", ::apache::thrift::protocol::T_I16, 15);
  xfer += oprot->writeI16(this->attackSing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackInterval", ::apache::thrift::protocol::T_I16, 16);
  xfer += oprot->writeI16(this->attackInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackDistance", ::apache::thrift::protocol::T_I16, 17);
  xfer += oprot->writeI16(this->attackDistance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("moveSpeed", ::apache::thrift::protocol::T_I16, 18);
  xfer += oprot->writeI16(this->moveSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hurtAbsorb", ::apache::thrift::protocol::T_I16, 19);
  xfer += oprot->writeI16(this->hurtAbsorb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hpAbsorb", ::apache::thrift::protocol::T_I16, 20);
  xfer += oprot->writeI16(this->hpAbsorb);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fightPower", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->fightPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("anger", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->anger);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angerMax", ::apache::thrift::protocol::T_I32, 23);
  xfer += oprot->writeI32(this->angerMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerPropRet &a, PlayerPropRet &b) {
  using ::std::swap;
  swap(a.baseInfo, b.baseInfo);
  swap(a.physicAttackMin, b.physicAttackMin);
  swap(a.physicAttackMax, b.physicAttackMax);
  swap(a.magicAttackMin, b.magicAttackMin);
  swap(a.magicAttackMax, b.magicAttackMax);
  swap(a.physicDefendMin, b.physicDefendMin);
  swap(a.physicDefendMax, b.physicDefendMax);
  swap(a.magicDefendMin, b.magicDefendMin);
  swap(a.magicDefendMax, b.magicDefendMax);
  swap(a.gold, b.gold);
  swap(a.crit, b.crit);
  swap(a.hit, b.hit);
  swap(a.avoid, b.avoid);
  swap(a.attackSpeed, b.attackSpeed);
  swap(a.attackSing, b.attackSing);
  swap(a.attackInterval, b.attackInterval);
  swap(a.attackDistance, b.attackDistance);
  swap(a.moveSpeed, b.moveSpeed);
  swap(a.hurtAbsorb, b.hurtAbsorb);
  swap(a.hpAbsorb, b.hpAbsorb);
  swap(a.fightPower, b.fightPower);
  swap(a.anger, b.anger);
  swap(a.angerMax, b.angerMax);
  swap(a.__isset, b.__isset);
}

const char* MonsterEnterMapRet::ascii_fingerprint = "EDEB7F903B121F7EA6BF662E33E4D667";
const uint8_t MonsterEnterMapRet::binary_fingerprint[16] = {0xED,0xEB,0x7F,0x90,0x3B,0x12,0x1F,0x7E,0xA6,0xBF,0x66,0x2E,0x33,0xE4,0xD6,0x67};

uint32_t MonsterEnterMapRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->appr);
          this->__isset.appr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->direction);
          this->__isset.direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hp);
          this->__isset.hp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hpMax);
          this->__isset.hpMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cfgId);
          this->__isset.cfgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MonsterEnterMapRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MonsterEnterMapRet");

  xfer += oprot->writeFieldBegin("appr", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->appr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hp", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->hp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hpMax", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->hpMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cfgId", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->cfgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MonsterEnterMapRet &a, MonsterEnterMapRet &b) {
  using ::std::swap;
  swap(a.appr, b.appr);
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.direction, b.direction);
  swap(a.hp, b.hp);
  swap(a.hpMax, b.hpMax);
  swap(a.cfgId, b.cfgId);
  swap(a.level, b.level);
  swap(a.__isset, b.__isset);
}

const char* NpcEnterMapRet::ascii_fingerprint = "521A40ACDE2E5E43ECA35444C556B226";
const uint8_t NpcEnterMapRet::binary_fingerprint[16] = {0x52,0x1A,0x40,0xAC,0xDE,0x2E,0x5E,0x43,0xEC,0xA3,0x54,0x44,0xC5,0x56,0xB2,0x26};

uint32_t NpcEnterMapRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->appr);
          this->__isset.appr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->direction);
          this->__isset.direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cfgid);
          this->__isset.cfgid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NpcEnterMapRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NpcEnterMapRet");

  xfer += oprot->writeFieldBegin("appr", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->appr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cfgid", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->cfgid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NpcEnterMapRet &a, NpcEnterMapRet &b) {
  using ::std::swap;
  swap(a.appr, b.appr);
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.direction, b.direction);
  swap(a.cfgid, b.cfgid);
  swap(a.__isset, b.__isset);
}

const char* ClickNpcReq::ascii_fingerprint = "727CAEA8265A5DE67DBC931F55CD8753";
const uint8_t ClickNpcReq::binary_fingerprint[16] = {0x72,0x7C,0xAE,0xA8,0x26,0x5A,0x5D,0xE6,0x7D,0xBC,0x93,0x1F,0x55,0xCD,0x87,0x53};

uint32_t ClickNpcReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->link);
          this->__isset.link = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClickNpcReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClickNpcReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("link", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->link);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClickNpcReq &a, ClickNpcReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.link, b.link);
  swap(a.__isset, b.__isset);
}

const char* NpcButton::ascii_fingerprint = "07A9615F837F7D0A952B595DD3020972";
const uint8_t NpcButton::binary_fingerprint[16] = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

uint32_t NpcButton::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clickCallbackArg);
          this->__isset.clickCallbackArg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->showText);
          this->__isset.showText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NpcButton::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NpcButton");

  xfer += oprot->writeFieldBegin("clickCallbackArg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clickCallbackArg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("showText", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->showText);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NpcButton &a, NpcButton &b) {
  using ::std::swap;
  swap(a.clickCallbackArg, b.clickCallbackArg);
  swap(a.showText, b.showText);
  swap(a.__isset, b.__isset);
}

const char* ClickNpcRet::ascii_fingerprint = "633E2ED96C122D44E3134847C5D501E9";
const uint8_t ClickNpcRet::binary_fingerprint[16] = {0x63,0x3E,0x2E,0xD9,0x6C,0x12,0x2D,0x44,0xE3,0x13,0x48,0x47,0xC5,0xD5,0x01,0xE9};

uint32_t ClickNpcRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->buttons.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->buttons.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += this->buttons[_i92].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.buttons = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ClickNpcRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ClickNpcRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buttons", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->buttons.size()));
    std::vector<NpcButton> ::const_iterator _iter93;
    for (_iter93 = this->buttons.begin(); _iter93 != this->buttons.end(); ++_iter93)
    {
      xfer += (*_iter93).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ClickNpcRet &a, ClickNpcRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.content, b.content);
  swap(a.buttons, b.buttons);
  swap(a.__isset, b.__isset);
}

const char* PlayerLogoutRet::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t PlayerLogoutRet::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t PlayerLogoutRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerLogoutRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PlayerLogoutRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerLogoutRet &a, PlayerLogoutRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* EnterMapReq::ascii_fingerprint = "28C2ECC89260BADB9C70330FBF47BFA8";
const uint8_t EnterMapReq::binary_fingerprint[16] = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};

uint32_t EnterMapReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mapname);
          this->__isset.mapname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnterMapReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EnterMapReq");

  xfer += oprot->writeFieldBegin("mapname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->mapname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnterMapReq &a, EnterMapReq &b) {
  using ::std::swap;
  swap(a.mapname, b.mapname);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

const char* EnterMapRet::ascii_fingerprint = "E6F30AA0A31E28DA51E71801F4422025";
const uint8_t EnterMapRet::binary_fingerprint[16] = {0xE6,0xF3,0x0A,0xA0,0xA3,0x1E,0x28,0xDA,0x51,0xE7,0x18,0x01,0xF4,0x42,0x20,0x25};

uint32_t EnterMapRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->playerinfo.read(iprot);
          this->__isset.playerinfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EnterMapRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("EnterMapRet");

  xfer += oprot->writeFieldBegin("playerinfo", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->playerinfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EnterMapRet &a, EnterMapRet &b) {
  using ::std::swap;
  swap(a.playerinfo, b.playerinfo);
  swap(a.__isset, b.__isset);
}

const char* LeaveMapRet::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t LeaveMapRet::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t LeaveMapRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LeaveMapRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LeaveMapRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LeaveMapRet &a, LeaveMapRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* Pos::ascii_fingerprint = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
const uint8_t Pos::binary_fingerprint[16] = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

uint32_t Pos::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Pos::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Pos");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pos &a, Pos &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

const char* MoveReq::ascii_fingerprint = "3E7765496BCF0063C35428E22F902724";
const uint8_t MoveReq::binary_fingerprint[16] = {0x3E,0x77,0x65,0x49,0x6B,0xCF,0x00,0x63,0xC3,0x54,0x28,0xE2,0x2F,0x90,0x27,0x24};

uint32_t MoveReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->direction);
          this->__isset.direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MoveReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MoveReq");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MoveReq &a, MoveReq &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.direction, b.direction);
  swap(a.__isset, b.__isset);
}

const char* MoveRet::ascii_fingerprint = "35EA2D514266E3F8074ACFFC7E913932";
const uint8_t MoveRet::binary_fingerprint[16] = {0x35,0xEA,0x2D,0x51,0x42,0x66,0xE3,0xF8,0x07,0x4A,0xCF,0xFC,0x7E,0x91,0x39,0x32};

uint32_t MoveRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->direction);
          this->__isset.direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MoveRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MoveRet");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MoveRet &a, MoveRet &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.uid, b.uid);
  swap(a.direction, b.direction);
  swap(a.__isset, b.__isset);
}

const char* RightMsg::ascii_fingerprint = "EFB929595D312AC8F305D5A794CFEDA1";
const uint8_t RightMsg::binary_fingerprint[16] = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

uint32_t RightMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RightMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RightMsg");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RightMsg &a, RightMsg &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* ErrorMsgRet::ascii_fingerprint = "795B7916A8054465768F9E75A920985F";
const uint8_t ErrorMsgRet::binary_fingerprint[16] = {0x79,0x5B,0x79,0x16,0xA8,0x05,0x44,0x65,0x76,0x8F,0x9E,0x75,0xA9,0x20,0x98,0x5F};

uint32_t ErrorMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->errType);
          this->__isset.errType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->cmd);
          this->__isset.cmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->errMsg);
          this->__isset.errMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ErrorMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ErrorMsgRet");

  xfer += oprot->writeFieldBegin("errType", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->errType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmd", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->cmd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errMsg", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->errMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ErrorMsgRet &a, ErrorMsgRet &b) {
  using ::std::swap;
  swap(a.errType, b.errType);
  swap(a.cmd, b.cmd);
  swap(a.errMsg, b.errMsg);
  swap(a.__isset, b.__isset);
}

const char* FriendListMsgReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t FriendListMsgReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t FriendListMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FriendListMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FriendListMsgReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FriendListMsgReq &a, FriendListMsgReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* FriendMsgReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t FriendMsgReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t FriendMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FriendMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FriendMsgReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FriendMsgReq &a, FriendMsgReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* FriendMsgRet::ascii_fingerprint = "B2C808E513184D50E4F2A7F694E3E3FD";
const uint8_t FriendMsgRet::binary_fingerprint[16] = {0xB2,0xC8,0x08,0xE5,0x13,0x18,0x4D,0x50,0xE4,0xF2,0xA7,0xF6,0x94,0xE3,0xE3,0xFD};

uint32_t FriendMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->online);
          this->__isset.online = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FriendMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FriendMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("online", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->online);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FriendMsgRet &a, FriendMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.online, b.online);
  swap(a.__isset, b.__isset);
}

const char* FriendPlayerMsg::ascii_fingerprint = "84938B257982C836BE0180DA273AD6CA";
const uint8_t FriendPlayerMsg::binary_fingerprint[16] = {0x84,0x93,0x8B,0x25,0x79,0x82,0xC8,0x36,0xBE,0x01,0x80,0xDA,0x27,0x3A,0xD6,0xCA};

uint32_t FriendPlayerMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->online);
          this->__isset.online = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mapname);
          this->__isset.mapname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FriendPlayerMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FriendPlayerMsg");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("online", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->online);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapname", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->mapname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I16, 8);
  xfer += oprot->writeI16(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I16, 9);
  xfer += oprot->writeI16(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FriendPlayerMsg &a, FriendPlayerMsg &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.online, b.online);
  swap(a.mapname, b.mapname);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

const char* FriendListMsgRet::ascii_fingerprint = "69CFEADB4995D107A4ED53BF4A90974A";
const uint8_t FriendListMsgRet::binary_fingerprint[16] = {0x69,0xCF,0xEA,0xDB,0x49,0x95,0xD1,0x07,0xA4,0xED,0x53,0xBF,0x4A,0x90,0x97,0x4A};

uint32_t FriendListMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allPlayerInfo.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->allPlayerInfo.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += this->allPlayerInfo[_i98].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allPlayerInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allEnemyInfo.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            this->allEnemyInfo.resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += this->allEnemyInfo[_i103].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allEnemyInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allShieldInfo.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->allShieldInfo.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += this->allShieldInfo[_i108].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allShieldInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FriendListMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FriendListMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allPlayerInfo", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allPlayerInfo.size()));
    std::vector<FriendPlayerMsg> ::const_iterator _iter109;
    for (_iter109 = this->allPlayerInfo.begin(); _iter109 != this->allPlayerInfo.end(); ++_iter109)
    {
      xfer += (*_iter109).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allEnemyInfo", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allEnemyInfo.size()));
    std::vector<FriendPlayerMsg> ::const_iterator _iter110;
    for (_iter110 = this->allEnemyInfo.begin(); _iter110 != this->allEnemyInfo.end(); ++_iter110)
    {
      xfer += (*_iter110).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allShieldInfo", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allShieldInfo.size()));
    std::vector<FriendPlayerMsg> ::const_iterator _iter111;
    for (_iter111 = this->allShieldInfo.begin(); _iter111 != this->allShieldInfo.end(); ++_iter111)
    {
      xfer += (*_iter111).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FriendListMsgRet &a, FriendListMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.allPlayerInfo, b.allPlayerInfo);
  swap(a.allEnemyInfo, b.allEnemyInfo);
  swap(a.allShieldInfo, b.allShieldInfo);
  swap(a.__isset, b.__isset);
}

const char* ChatMsgReq::ascii_fingerprint = "55F2239516C9C08DB41231C56B29843E";
const uint8_t ChatMsgReq::binary_fingerprint[16] = {0x55,0xF2,0x23,0x95,0x16,0xC9,0xC0,0x8D,0xB4,0x12,0x31,0xC5,0x6B,0x29,0x84,0x3E};

uint32_t ChatMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->chatMsg);
          this->__isset.chatMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChatMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ChatMsgReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chatMsg", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->chatMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChatMsgReq &a, ChatMsgReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.chatMsg, b.chatMsg);
  swap(a.__isset, b.__isset);
}

const char* ChatMsgRet::ascii_fingerprint = "E99B229DDCD93C6B7C52470E27CAD875";
const uint8_t ChatMsgRet::binary_fingerprint[16] = {0xE9,0x9B,0x22,0x9D,0xDC,0xD9,0x3C,0x6B,0x7C,0x52,0x47,0x0E,0x27,0xCA,0xD8,0x75};

uint32_t ChatMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->chatMsg);
          this->__isset.chatMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChatMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ChatMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chatMsg", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->chatMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChatMsgRet &a, ChatMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.chatMsg, b.chatMsg);
  swap(a.__isset, b.__isset);
}

const char* TeamMsgReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t TeamMsgReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t TeamMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TeamMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TeamMsgReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TeamMsgReq &a, TeamMsgReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* TeamListMsgReq::ascii_fingerprint = "565787C31CF2D774B532CB755189BF39";
const uint8_t TeamListMsgReq::binary_fingerprint[16] = {0x56,0x57,0x87,0xC3,0x1C,0xF2,0xD7,0x74,0xB5,0x32,0xCB,0x75,0x51,0x89,0xBF,0x39};

uint32_t TeamListMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TeamListMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TeamListMsgReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TeamListMsgReq &a, TeamListMsgReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.__isset, b.__isset);
}

const char* TeamMsgRet::ascii_fingerprint = "C789858F54E48ADE06D97C7BCD3E2DE7";
const uint8_t TeamMsgRet::binary_fingerprint[16] = {0xC7,0x89,0x85,0x8F,0x54,0xE4,0x8A,0xDE,0x06,0xD9,0x7C,0x7B,0xCD,0x3E,0x2D,0xE7};

uint32_t TeamMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hp);
          this->__isset.hp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hpMax);
          this->__isset.hpMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mp);
          this->__isset.mp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mpMax);
          this->__isset.mpMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->anger);
          this->__isset.anger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->angerMax);
          this->__isset.angerMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->leader);
          this->__isset.leader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TeamMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TeamMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hp", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->hp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hpMax", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->hpMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mp", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->mp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mpMax", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->mpMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("anger", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->anger);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angerMax", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->angerMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leader", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->leader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TeamMsgRet &a, TeamMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.hp, b.hp);
  swap(a.hpMax, b.hpMax);
  swap(a.mp, b.mp);
  swap(a.mpMax, b.mpMax);
  swap(a.anger, b.anger);
  swap(a.angerMax, b.angerMax);
  swap(a.leader, b.leader);
  swap(a.__isset, b.__isset);
}

const char* TeamPlayerMsg::ascii_fingerprint = "D01293B3A60C4EA89FD22642D4FF24ED";
const uint8_t TeamPlayerMsg::binary_fingerprint[16] = {0xD0,0x12,0x93,0xB3,0xA6,0x0C,0x4E,0xA8,0x9F,0xD2,0x26,0x42,0xD4,0xFF,0x24,0xED};

uint32_t TeamPlayerMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hp);
          this->__isset.hp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hpMax);
          this->__isset.hpMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mp);
          this->__isset.mp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mpMax);
          this->__isset.mpMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->anger);
          this->__isset.anger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->angerMax);
          this->__isset.angerMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->leader);
          this->__isset.leader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TeamPlayerMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TeamPlayerMsg");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hp", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->hp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hpMax", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->hpMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mp", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->mp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mpMax", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->mpMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("anger", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->anger);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angerMax", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->angerMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leader", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->leader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TeamPlayerMsg &a, TeamPlayerMsg &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.hp, b.hp);
  swap(a.hpMax, b.hpMax);
  swap(a.mp, b.mp);
  swap(a.mpMax, b.mpMax);
  swap(a.anger, b.anger);
  swap(a.angerMax, b.angerMax);
  swap(a.leader, b.leader);
  swap(a.__isset, b.__isset);
}

const char* TeamListMsgRet::ascii_fingerprint = "817CFC20265A9EF8BBAF7029CBE582AF";
const uint8_t TeamListMsgRet::binary_fingerprint[16] = {0x81,0x7C,0xFC,0x20,0x26,0x5A,0x9E,0xF8,0xBB,0xAF,0x70,0x29,0xCB,0xE5,0x82,0xAF};

uint32_t TeamListMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allTeamInfo.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->allTeamInfo.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += this->allTeamInfo[_i116].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allTeamInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TeamListMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TeamListMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allTeamInfo", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allTeamInfo.size()));
    std::vector<TeamPlayerMsg> ::const_iterator _iter117;
    for (_iter117 = this->allTeamInfo.begin(); _iter117 != this->allTeamInfo.end(); ++_iter117)
    {
      xfer += (*_iter117).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TeamListMsgRet &a, TeamListMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.allTeamInfo, b.allTeamInfo);
  swap(a.__isset, b.__isset);
}

const char* BrotherOpsReq::ascii_fingerprint = "A497A0B16E8770B3A6B1EF9C68880EDA";
const uint8_t BrotherOpsReq::binary_fingerprint[16] = {0xA4,0x97,0xA0,0xB1,0x6E,0x87,0x70,0xB3,0xA6,0xB1,0xEF,0x9C,0x68,0x88,0x0E,0xDA};

uint32_t BrotherOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid1);
          this->__isset.uid1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid2);
          this->__isset.uid2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BrotherOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BrotherOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid1", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid2", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->uid2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BrotherOpsReq &a, BrotherOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid1, b.uid1);
  swap(a.uid2, b.uid2);
  swap(a.__isset, b.__isset);
}

const char* BrotherPlayerMsg::ascii_fingerprint = "AA8FBFDE43AA8831121986F0B5BC34BC";
const uint8_t BrotherPlayerMsg::binary_fingerprint[16] = {0xAA,0x8F,0xBF,0xDE,0x43,0xAA,0x88,0x31,0x12,0x19,0x86,0xF0,0xB5,0xBC,0x34,0xBC};

uint32_t BrotherPlayerMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->online);
          this->__isset.online = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BrotherPlayerMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BrotherPlayerMsg");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("online", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->online);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BrotherPlayerMsg &a, BrotherPlayerMsg &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.online, b.online);
  swap(a.__isset, b.__isset);
}

const char* BrotherOpsMsgRet::ascii_fingerprint = "6275BED1B77840C243E493EDC02B9159";
const uint8_t BrotherOpsMsgRet::binary_fingerprint[16] = {0x62,0x75,0xBE,0xD1,0xB7,0x78,0x40,0xC2,0x43,0xE4,0x93,0xED,0xC0,0x2B,0x91,0x59};

uint32_t BrotherOpsMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allBrotherInfo.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->allBrotherInfo.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += this->allBrotherInfo[_i122].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allBrotherInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->flag);
          this->__isset.flag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delTime);
          this->__isset.delTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BrotherOpsMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BrotherOpsMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allBrotherInfo", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allBrotherInfo.size()));
    std::vector<BrotherPlayerMsg> ::const_iterator _iter123;
    for (_iter123 = this->allBrotherInfo.begin(); _iter123 != this->allBrotherInfo.end(); ++_iter123)
    {
      xfer += (*_iter123).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flag", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->flag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delTime", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->delTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BrotherOpsMsgRet &a, BrotherOpsMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.allBrotherInfo, b.allBrotherInfo);
  swap(a.flag, b.flag);
  swap(a.delTime, b.delTime);
  swap(a.__isset, b.__isset);
}

const char* NormalMsg::ascii_fingerprint = "961A06D18A14C4C951D88951A6A71ED3";
const uint8_t NormalMsg::binary_fingerprint[16] = {0x96,0x1A,0x06,0xD1,0x8A,0x14,0xC4,0xC9,0x51,0xD8,0x89,0x51,0xA6,0xA7,0x1E,0xD3};

uint32_t NormalMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->cmd);
          this->__isset.cmd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Msg);
          this->__isset.Msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NormalMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("NormalMsg");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cmd", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->cmd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Msg", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->Msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NormalMsg &a, NormalMsg &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.cmd, b.cmd);
  swap(a.uid, b.uid);
  swap(a.Msg, b.Msg);
  swap(a.__isset, b.__isset);
}

const char* PlayerMsg::ascii_fingerprint = "A0E7CB44EAF8FB115318DA7C81C6F72C";
const uint8_t PlayerMsg::binary_fingerprint[16] = {0xA0,0xE7,0xCB,0x44,0xEA,0xF8,0xFB,0x11,0x53,0x18,0xDA,0x7C,0x81,0xC6,0xF7,0x2C};

uint32_t PlayerMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->flag);
          this->__isset.flag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PlayerMsg");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flag", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->flag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerMsg &a, PlayerMsg &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.flag, b.flag);
  swap(a.__isset, b.__isset);
}

const char* UpdateSkillPosReq::ascii_fingerprint = "069CEB68BE029AE8039692D6DE20B68F";
const uint8_t UpdateSkillPosReq::binary_fingerprint[16] = {0x06,0x9C,0xEB,0x68,0xBE,0x02,0x9A,0xE8,0x03,0x96,0x92,0xD6,0xDE,0x20,0xB6,0x8F};

uint32_t UpdateSkillPosReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->skill2pos.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              int32_t _key129;
              xfer += iprot->readI32(_key129);
              int32_t& _val130 = this->skill2pos[_key129];
              xfer += iprot->readI32(_val130);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.skill2pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateSkillPosReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateSkillPosReq");

  xfer += oprot->writeFieldBegin("skill2pos", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->skill2pos.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter131;
    for (_iter131 = this->skill2pos.begin(); _iter131 != this->skill2pos.end(); ++_iter131)
    {
      xfer += oprot->writeI32(_iter131->first);
      xfer += oprot->writeI32(_iter131->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateSkillPosReq &a, UpdateSkillPosReq &b) {
  using ::std::swap;
  swap(a.skill2pos, b.skill2pos);
  swap(a.__isset, b.__isset);
}

const char* UpdateSkillPosRet::ascii_fingerprint = "069CEB68BE029AE8039692D6DE20B68F";
const uint8_t UpdateSkillPosRet::binary_fingerprint[16] = {0x06,0x9C,0xEB,0x68,0xBE,0x02,0x9A,0xE8,0x03,0x96,0x92,0xD6,0xDE,0x20,0xB6,0x8F};

uint32_t UpdateSkillPosRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->skill2pos.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _ktype133;
            ::apache::thrift::protocol::TType _vtype134;
            xfer += iprot->readMapBegin(_ktype133, _vtype134, _size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              int32_t _key137;
              xfer += iprot->readI32(_key137);
              int32_t& _val138 = this->skill2pos[_key137];
              xfer += iprot->readI32(_val138);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.skill2pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateSkillPosRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateSkillPosRet");

  xfer += oprot->writeFieldBegin("skill2pos", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->skill2pos.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter139;
    for (_iter139 = this->skill2pos.begin(); _iter139 != this->skill2pos.end(); ++_iter139)
    {
      xfer += oprot->writeI32(_iter139->first);
      xfer += oprot->writeI32(_iter139->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateSkillPosRet &a, UpdateSkillPosRet &b) {
  using ::std::swap;
  swap(a.skill2pos, b.skill2pos);
  swap(a.__isset, b.__isset);
}

const char* MakeItemReq::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t MakeItemReq::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t MakeItemReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemCfgId);
          this->__isset.itemCfgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MakeItemReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MakeItemReq");

  xfer += oprot->writeFieldBegin("itemCfgId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->itemCfgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MakeItemReq &a, MakeItemReq &b) {
  using ::std::swap;
  swap(a.itemCfgId, b.itemCfgId);
  swap(a.__isset, b.__isset);
}

const char* MakeItemRet::ascii_fingerprint = "119BE3D2A63DA2F330BA9AB099697A66";
const uint8_t MakeItemRet::binary_fingerprint[16] = {0x11,0x9B,0xE3,0xD2,0xA6,0x3D,0xA2,0xF3,0x30,0xBA,0x9A,0xB0,0x99,0x69,0x7A,0x66};

uint32_t MakeItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->itemMaked.read(iprot);
          this->__isset.itemMaked = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MakeItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MakeItemRet");

  xfer += oprot->writeFieldBegin("itemMaked", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->itemMaked.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MakeItemRet &a, MakeItemRet &b) {
  using ::std::swap;
  swap(a.itemMaked, b.itemMaked);
  swap(a.exp, b.exp);
  swap(a.level, b.level);
  swap(a.__isset, b.__isset);
}

const char* InheritItemReq::ascii_fingerprint = "F33135321253DAEB67B0E79E416CA831";
const uint8_t InheritItemReq::binary_fingerprint[16] = {0xF3,0x31,0x35,0x32,0x12,0x53,0xDA,0xEB,0x67,0xB0,0xE7,0x9E,0x41,0x6C,0xA8,0x31};

uint32_t InheritItemReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidFrom);
          this->__isset.uidFrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidTo);
          this->__isset.uidTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InheritItemReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("InheritItemReq");

  xfer += oprot->writeFieldBegin("uidFrom", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uidFrom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uidTo", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uidTo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InheritItemReq &a, InheritItemReq &b) {
  using ::std::swap;
  swap(a.uidFrom, b.uidFrom);
  swap(a.uidTo, b.uidTo);
  swap(a.__isset, b.__isset);
}

const char* InheritItemRet::ascii_fingerprint = "FA61667049EBDDC71C62C8122446288D";
const uint8_t InheritItemRet::binary_fingerprint[16] = {0xFA,0x61,0x66,0x70,0x49,0xEB,0xDD,0xC7,0x1C,0x62,0xC8,0x12,0x24,0x46,0x28,0x8D};

uint32_t InheritItemRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidFrom);
          this->__isset.uidFrom = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidTo);
          this->__isset.uidTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->itemTo.read(iprot);
          this->__isset.itemTo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InheritItemRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("InheritItemRet");

  xfer += oprot->writeFieldBegin("uidFrom", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uidFrom);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uidTo", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uidTo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemTo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->itemTo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InheritItemRet &a, InheritItemRet &b) {
  using ::std::swap;
  swap(a.uidFrom, b.uidFrom);
  swap(a.uidTo, b.uidTo);
  swap(a.itemTo, b.itemTo);
  swap(a.__isset, b.__isset);
}

const char* BuffStatus::ascii_fingerprint = "559AD6C7C62CC031B86442A730D47DD9";
const uint8_t BuffStatus::binary_fingerprint[16] = {0x55,0x9A,0xD6,0xC7,0xC6,0x2C,0xC0,0x31,0xB8,0x64,0x42,0xA7,0x30,0xD4,0x7D,0xD9};

uint32_t BuffStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->endTime);
          this->__isset.endTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->param.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _ktype141;
            ::apache::thrift::protocol::TType _vtype142;
            xfer += iprot->readMapBegin(_ktype141, _vtype142, _size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              int16_t _key145;
              xfer += iprot->readI16(_key145);
              int32_t& _val146 = this->param[_key145];
              xfer += iprot->readI32(_val146);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->triggerSkill);
          this->__isset.triggerSkill = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BuffStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BuffStatus");

  xfer += oprot->writeFieldBegin("endTime", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->endTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->param.size()));
    std::map<int16_t, int32_t> ::const_iterator _iter147;
    for (_iter147 = this->param.begin(); _iter147 != this->param.end(); ++_iter147)
    {
      xfer += oprot->writeI16(_iter147->first);
      xfer += oprot->writeI32(_iter147->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("triggerSkill", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->triggerSkill);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BuffStatus &a, BuffStatus &b) {
  using ::std::swap;
  swap(a.endTime, b.endTime);
  swap(a.param, b.param);
  swap(a.triggerSkill, b.triggerSkill);
  swap(a.__isset, b.__isset);
}

const char* UpdateBuffRet::ascii_fingerprint = "74C11ACD2AC7C882B5D06FDE4880DE92";
const uint8_t UpdateBuffRet::binary_fingerprint[16] = {0x74,0xC1,0x1A,0xCD,0x2A,0xC7,0xC8,0x82,0xB5,0xD0,0x6F,0xDE,0x48,0x80,0xDE,0x92};

uint32_t UpdateBuffRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->allBuff.clear();
            uint32_t _size148;
            ::apache::thrift::protocol::TType _ktype149;
            ::apache::thrift::protocol::TType _vtype150;
            xfer += iprot->readMapBegin(_ktype149, _vtype150, _size148);
            uint32_t _i152;
            for (_i152 = 0; _i152 < _size148; ++_i152)
            {
              int16_t _key153;
              xfer += iprot->readI16(_key153);
              BuffStatus& _val154 = this->allBuff[_key153];
              xfer += _val154.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.allBuff = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateBuffRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("UpdateBuffRet");

  xfer += oprot->writeFieldBegin("allBuff", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allBuff.size()));
    std::map<int16_t, BuffStatus> ::const_iterator _iter155;
    for (_iter155 = this->allBuff.begin(); _iter155 != this->allBuff.end(); ++_iter155)
    {
      xfer += oprot->writeI16(_iter155->first);
      xfer += _iter155->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateBuffRet &a, UpdateBuffRet &b) {
  using ::std::swap;
  swap(a.allBuff, b.allBuff);
  swap(a.__isset, b.__isset);
}

const char* ShowEffectRet::ascii_fingerprint = "C1D653683FE2A0AE29A27D5C67B4E56D";
const uint8_t ShowEffectRet::binary_fingerprint[16] = {0xC1,0xD6,0x53,0x68,0x3F,0xE2,0xA0,0xAE,0x29,0xA2,0x7D,0x5C,0x67,0xB4,0xE5,0x6D};

uint32_t ShowEffectRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->effectType);
          this->__isset.effectType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->param.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _ktype157;
            ::apache::thrift::protocol::TType _vtype158;
            xfer += iprot->readMapBegin(_ktype157, _vtype158, _size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              int16_t _key161;
              xfer += iprot->readI16(_key161);
              int32_t& _val162 = this->param[_key161];
              xfer += iprot->readI32(_val162);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowEffectRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ShowEffectRet");

  xfer += oprot->writeFieldBegin("effectType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->effectType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I16, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->param.size()));
    std::map<int16_t, int32_t> ::const_iterator _iter163;
    for (_iter163 = this->param.begin(); _iter163 != this->param.end(); ++_iter163)
    {
      xfer += oprot->writeI16(_iter163->first);
      xfer += oprot->writeI32(_iter163->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowEffectRet &a, ShowEffectRet &b) {
  using ::std::swap;
  swap(a.effectType, b.effectType);
  swap(a.param, b.param);
  swap(a.__isset, b.__isset);
}

const char* ShowPlayRet::ascii_fingerprint = "9C2A05F173B50306037BDE9AE30E1B99";
const uint8_t ShowPlayRet::binary_fingerprint[16] = {0x9C,0x2A,0x05,0xF1,0x73,0xB5,0x03,0x06,0x03,0x7B,0xDE,0x9A,0xE3,0x0E,0x1B,0x99};

uint32_t ShowPlayRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->playId);
          this->__isset.playId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->callbackId);
          this->__isset.callbackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowPlayRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ShowPlayRet");

  xfer += oprot->writeFieldBegin("playId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->playId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("callbackId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->callbackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowPlayRet &a, ShowPlayRet &b) {
  using ::std::swap;
  swap(a.playId, b.playId);
  swap(a.callbackId, b.callbackId);
  swap(a.__isset, b.__isset);
}

const char* ShowUiRet::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t ShowUiRet::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t ShowUiRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uitype);
          this->__isset.uitype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowUiRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ShowUiRet");

  xfer += oprot->writeFieldBegin("uitype", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uitype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowUiRet &a, ShowUiRet &b) {
  using ::std::swap;
  swap(a.uitype, b.uitype);
  swap(a.__isset, b.__isset);
}

const char* CollectOpsReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t CollectOpsReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t CollectOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CollectOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CollectOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CollectOpsReq &a, CollectOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* CollectOpsRet::ascii_fingerprint = "0ABA6C36855667878A7C60D88FE6EE5A";
const uint8_t CollectOpsRet::binary_fingerprint[16] = {0x0A,0xBA,0x6C,0x36,0x85,0x56,0x67,0x87,0x8A,0x7C,0x60,0xD8,0x8F,0xE6,0xEE,0x5A};

uint32_t CollectOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->needSec);
          this->__isset.needSec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->item.read(iprot);
          this->__isset.item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cfgid);
          this->__isset.cfgid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CollectOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CollectOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("needSec", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->needSec);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cfgid", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->cfgid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CollectOpsRet &a, CollectOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.needSec, b.needSec);
  swap(a.item, b.item);
  swap(a.cfgid, b.cfgid);
  swap(a.__isset, b.__isset);
}

const char* TransferPointOpsReq::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t TransferPointOpsReq::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t TransferPointOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cfgid);
          this->__isset.cfgid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TransferPointOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("TransferPointOpsReq");

  xfer += oprot->writeFieldBegin("cfgid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cfgid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TransferPointOpsReq &a, TransferPointOpsReq &b) {
  using ::std::swap;
  swap(a.cfgid, b.cfgid);
  swap(a.__isset, b.__isset);
}

const char* Pet::ascii_fingerprint = "B58C08E2EEAE473E14E607E463683619";
const uint8_t Pet::binary_fingerprint[16] = {0xB5,0x8C,0x08,0xE2,0xEE,0xAE,0x47,0x3E,0x14,0xE6,0x07,0xE4,0x63,0x68,0x36,0x19};

uint32_t Pet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expMax);
          this->__isset.expMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->quality);
          this->__isset.quality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->cfgid);
          this->__isset.cfgid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->propExt.clear();
            uint32_t _size164;
            ::apache::thrift::protocol::TType _ktype165;
            ::apache::thrift::protocol::TType _vtype166;
            xfer += iprot->readMapBegin(_ktype165, _vtype166, _size164);
            uint32_t _i168;
            for (_i168 = 0; _i168 < _size164; ++_i168)
            {
              int32_t _key169;
              xfer += iprot->readI32(_key169);
              int32_t& _val170 = this->propExt[_key169];
              xfer += iprot->readI32(_val170);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.propExt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Pet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Pet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expMax", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->expMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quality", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->quality);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cfgid", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->cfgid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("propExt", ::apache::thrift::protocol::T_MAP, 8);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->propExt.size()));
    std::map<int32_t, int32_t> ::const_iterator _iter171;
    for (_iter171 = this->propExt.begin(); _iter171 != this->propExt.end(); ++_iter171)
    {
      xfer += oprot->writeI32(_iter171->first);
      xfer += oprot->writeI32(_iter171->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pet &a, Pet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.status, b.status);
  swap(a.level, b.level);
  swap(a.exp, b.exp);
  swap(a.expMax, b.expMax);
  swap(a.quality, b.quality);
  swap(a.cfgid, b.cfgid);
  swap(a.propExt, b.propExt);
  swap(a.__isset, b.__isset);
}

const char* PetEgg::ascii_fingerprint = "6435B39C87AB0E30F30BEDEFD7328C0D";
const uint8_t PetEgg::binary_fingerprint[16] = {0x64,0x35,0xB3,0x9C,0x87,0xAB,0x0E,0x30,0xF3,0x0B,0xED,0xEF,0xD7,0x32,0x8C,0x0D};

uint32_t PetEgg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->eggItemCfgId);
          this->__isset.eggItemCfgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->starttm);
          this->__isset.starttm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->needsec);
          this->__isset.needsec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PetEgg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PetEgg");

  xfer += oprot->writeFieldBegin("eggItemCfgId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->eggItemCfgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("starttm", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->starttm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("needsec", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->needsec);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PetEgg &a, PetEgg &b) {
  using ::std::swap;
  swap(a.eggItemCfgId, b.eggItemCfgId);
  swap(a.starttm, b.starttm);
  swap(a.needsec, b.needsec);
  swap(a.__isset, b.__isset);
}

const char* PetInfoRet::ascii_fingerprint = "AAF9485AD14864F4C8C85DAA99065173";
const uint8_t PetInfoRet::binary_fingerprint[16] = {0xAA,0xF9,0x48,0x5A,0xD1,0x48,0x64,0xF4,0xC8,0xC8,0x5D,0xAA,0x99,0x06,0x51,0x73};

uint32_t PetInfoRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allPet.clear();
            uint32_t _size172;
            ::apache::thrift::protocol::TType _etype175;
            xfer += iprot->readListBegin(_etype175, _size172);
            this->allPet.resize(_size172);
            uint32_t _i176;
            for (_i176 = 0; _i176 < _size172; ++_i176)
            {
              xfer += this->allPet[_i176].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allPet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->petEgg.read(iprot);
          this->__isset.petEgg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PetInfoRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PetInfoRet");

  xfer += oprot->writeFieldBegin("allPet", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allPet.size()));
    std::vector<Pet> ::const_iterator _iter177;
    for (_iter177 = this->allPet.begin(); _iter177 != this->allPet.end(); ++_iter177)
    {
      xfer += (*_iter177).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("petEgg", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->petEgg.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PetInfoRet &a, PetInfoRet &b) {
  using ::std::swap;
  swap(a.allPet, b.allPet);
  swap(a.petEgg, b.petEgg);
  swap(a.__isset, b.__isset);
}

const char* PetEggStartReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t PetEggStartReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t PetEggStartReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PetEggStartReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PetEggStartReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PetEggStartReq &a, PetEggStartReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* FeedPetReq::ascii_fingerprint = "955BD89722154769CC8FC8E9E0AB6CC2";
const uint8_t FeedPetReq::binary_fingerprint[16] = {0x95,0x5B,0xD8,0x97,0x22,0x15,0x47,0x69,0xCC,0x8F,0xC8,0xE9,0xE0,0xAB,0x6C,0xC2};

uint32_t FeedPetReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->item.clear();
            uint32_t _size178;
            ::apache::thrift::protocol::TType _etype181;
            xfer += iprot->readListBegin(_etype181, _size178);
            this->item.resize(_size178);
            uint32_t _i182;
            for (_i182 = 0; _i182 < _size178; ++_i182)
            {
              xfer += iprot->readI64(this->item[_i182]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FeedPetReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FeedPetReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->item.size()));
    std::vector<int64_t> ::const_iterator _iter183;
    for (_iter183 = this->item.begin(); _iter183 != this->item.end(); ++_iter183)
    {
      xfer += oprot->writeI64((*_iter183));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FeedPetReq &a, FeedPetReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.item, b.item);
  swap(a.__isset, b.__isset);
}

const char* PetOpsReq::ascii_fingerprint = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
const uint8_t PetOpsReq::binary_fingerprint[16] = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

uint32_t PetOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PetOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PetOpsReq");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PetOpsReq &a, PetOpsReq &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* PetOpsRet::ascii_fingerprint = "9266EB424AB01BC22C7C74911C62D1E0";
const uint8_t PetOpsRet::binary_fingerprint[16] = {0x92,0x66,0xEB,0x42,0x4A,0xB0,0x1B,0xC2,0x2C,0x7C,0x74,0x91,0x1C,0x62,0xD1,0xE0};

uint32_t PetOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PetOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PetOpsRet");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PetOpsRet &a, PetOpsRet &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* BurstRandInfo::ascii_fingerprint = "BCD2A68B104EEBD2418CF77F3D47035D";
const uint8_t BurstRandInfo::binary_fingerprint[16] = {0xBC,0xD2,0xA6,0x8B,0x10,0x4E,0xEB,0xD2,0x41,0x8C,0xF7,0x7F,0x3D,0x47,0x03,0x5D};

uint32_t BurstRandInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->randNum);
          this->__isset.randNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BurstRandInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("BurstRandInfo");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("randNum", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->randNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BurstRandInfo &a, BurstRandInfo &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.randNum, b.randNum);
  swap(a.__isset, b.__isset);
}

const char* MonserBurstItemsRet::ascii_fingerprint = "D20DBE615CB630C797C28F323ECA1AEB";
const uint8_t MonserBurstItemsRet::binary_fingerprint[16] = {0xD2,0x0D,0xBE,0x61,0x5C,0xB6,0x30,0xC7,0x97,0xC2,0x8F,0x32,0x3E,0xCA,0x1A,0xEB};

uint32_t MonserBurstItemsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidMon);
          this->__isset.uidMon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->toUid);
          this->__isset.toUid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->items.clear();
            uint32_t _size184;
            ::apache::thrift::protocol::TType _etype187;
            xfer += iprot->readListBegin(_etype187, _size184);
            this->items.resize(_size184);
            uint32_t _i188;
            for (_i188 = 0; _i188 < _size184; ++_i188)
            {
              xfer += this->items[_i188].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->teamBurstInfo.clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            this->teamBurstInfo.resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += this->teamBurstInfo[_i193].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.teamBurstInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->callbackId);
          this->__isset.callbackId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MonserBurstItemsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MonserBurstItemsRet");

  xfer += oprot->writeFieldBegin("uidMon", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uidMon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("toUid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->toUid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->items.size()));
    std::vector<Item> ::const_iterator _iter194;
    for (_iter194 = this->items.begin(); _iter194 != this->items.end(); ++_iter194)
    {
      xfer += (*_iter194).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("teamBurstInfo", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->teamBurstInfo.size()));
    std::vector<BurstRandInfo> ::const_iterator _iter195;
    for (_iter195 = this->teamBurstInfo.begin(); _iter195 != this->teamBurstInfo.end(); ++_iter195)
    {
      xfer += (*_iter195).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("callbackId", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->callbackId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MonserBurstItemsRet &a, MonserBurstItemsRet &b) {
  using ::std::swap;
  swap(a.uidMon, b.uidMon);
  swap(a.toUid, b.toUid);
  swap(a.items, b.items);
  swap(a.exp, b.exp);
  swap(a.gold, b.gold);
  swap(a.teamBurstInfo, b.teamBurstInfo);
  swap(a.callbackId, b.callbackId);
  swap(a.__isset, b.__isset);
}

const char* CopymapStartRet::ascii_fingerprint = "3F5FC93B338687BC7235B1AB103F47B3";
const uint8_t CopymapStartRet::binary_fingerprint[16] = {0x3F,0x5F,0xC9,0x3B,0x33,0x86,0x87,0xBC,0x72,0x35,0xB1,0xAB,0x10,0x3F,0x47,0xB3};

uint32_t CopymapStartRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxSec);
          this->__isset.maxSec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->intro);
          this->__isset.intro = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CopymapStartRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CopymapStartRet");

  xfer += oprot->writeFieldBegin("maxSec", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->maxSec);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intro", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->intro);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CopymapStartRet &a, CopymapStartRet &b) {
  using ::std::swap;
  swap(a.maxSec, b.maxSec);
  swap(a.intro, b.intro);
  swap(a.__isset, b.__isset);
}

const char* CopymapEndRet::ascii_fingerprint = "9D7ECC12612E90230EF4ED5A4CB2164E";
const uint8_t CopymapEndRet::binary_fingerprint[16] = {0x9D,0x7E,0xCC,0x12,0x61,0x2E,0x90,0x23,0x0E,0xF4,0xED,0x5A,0x4C,0xB2,0x16,0x4E};

uint32_t CopymapEndRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exp);
          this->__isset.exp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->items.clear();
            uint32_t _size196;
            ::apache::thrift::protocol::TType _etype199;
            xfer += iprot->readListBegin(_etype199, _size196);
            this->items.resize(_size196);
            uint32_t _i200;
            for (_i200 = 0; _i200 < _size196; ++_i200)
            {
              xfer += this->items[_i200].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CopymapEndRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CopymapEndRet");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exp", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->exp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->items.size()));
    std::vector<Item> ::const_iterator _iter201;
    for (_iter201 = this->items.begin(); _iter201 != this->items.end(); ++_iter201)
    {
      xfer += (*_iter201).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CopymapEndRet &a, CopymapEndRet &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.exp, b.exp);
  swap(a.gold, b.gold);
  swap(a.items, b.items);
  swap(a.__isset, b.__isset);
}

const char* RepoItemOpsReq::ascii_fingerprint = "4F80AF6A83E5E6099DC8ED56E304F0DA";
const uint8_t RepoItemOpsReq::binary_fingerprint[16] = {0x4F,0x80,0xAF,0x6A,0x83,0xE5,0xE6,0x09,0x9D,0xC8,0xED,0x56,0xE3,0x04,0xF0,0xDA};

uint32_t RepoItemOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->itemid);
          this->__isset.itemid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->destPos);
          this->__isset.destPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->destNum);
          this->__isset.destNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemNum);
          this->__isset.itemNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->position);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          this->__isset.passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RepoItemOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RepoItemOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->itemid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destPos", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->destPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destNum", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->destNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemNum", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->itemNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->position);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RepoItemOpsReq &a, RepoItemOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.itemid, b.itemid);
  swap(a.destPos, b.destPos);
  swap(a.destNum, b.destNum);
  swap(a.itemNum, b.itemNum);
  swap(a.position, b.position);
  swap(a.passwd, b.passwd);
  swap(a.__isset, b.__isset);
}

const char* RepoItemOpsRet::ascii_fingerprint = "50552048D82B8EF090AAFE9D3E69003A";
const uint8_t RepoItemOpsRet::binary_fingerprint[16] = {0x50,0x55,0x20,0x48,0xD8,0x2B,0x8E,0xF0,0x90,0xAA,0xFE,0x9D,0x3E,0x69,0x00,0x3A};

uint32_t RepoItemOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->itemid);
          this->__isset.itemid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->destPos);
          this->__isset.destPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->repoMaxSize);
          this->__isset.repoMaxSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->allItem.clear();
            uint32_t _size202;
            ::apache::thrift::protocol::TType _ktype203;
            ::apache::thrift::protocol::TType _vtype204;
            xfer += iprot->readMapBegin(_ktype203, _vtype204, _size202);
            uint32_t _i206;
            for (_i206 = 0; _i206 < _size202; ++_i206)
            {
              int32_t _key207;
              xfer += iprot->readI32(_key207);
              Item& _val208 = this->allItem[_key207];
              xfer += _val208.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.allItem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemNum);
          this->__isset.itemNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RepoItemOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RepoItemOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->itemid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destPos", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->destPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("repoMaxSize", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->repoMaxSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allItem", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allItem.size()));
    std::map<int32_t, Item> ::const_iterator _iter209;
    for (_iter209 = this->allItem.begin(); _iter209 != this->allItem.end(); ++_iter209)
    {
      xfer += oprot->writeI32(_iter209->first);
      xfer += _iter209->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemNum", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->itemNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RepoItemOpsRet &a, RepoItemOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.itemid, b.itemid);
  swap(a.destPos, b.destPos);
  swap(a.repoMaxSize, b.repoMaxSize);
  swap(a.allItem, b.allItem);
  swap(a.itemNum, b.itemNum);
  swap(a.__isset, b.__isset);
}

const char* ExchangeOpsReq::ascii_fingerprint = "43BCEB09E396FFE5F3682B27EF164EF0";
const uint8_t ExchangeOpsReq::binary_fingerprint[16] = {0x43,0xBC,0xEB,0x09,0xE3,0x96,0xFF,0xE5,0xF3,0x68,0x2B,0x27,0xEF,0x16,0x4E,0xF0};

uint32_t ExchangeOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->destuid);
          this->__isset.destuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->items.clear();
            uint32_t _size210;
            ::apache::thrift::protocol::TType _ktype211;
            ::apache::thrift::protocol::TType _vtype212;
            xfer += iprot->readMapBegin(_ktype211, _vtype212, _size210);
            uint32_t _i214;
            for (_i214 = 0; _i214 < _size210; ++_i214)
            {
              int64_t _key215;
              xfer += iprot->readI64(_key215);
              int32_t& _val216 = this->items[_key215];
              xfer += iprot->readI32(_val216);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExchangeOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ExchangeOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destuid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->destuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->items.size()));
    std::map<int64_t, int32_t> ::const_iterator _iter217;
    for (_iter217 = this->items.begin(); _iter217 != this->items.end(); ++_iter217)
    {
      xfer += oprot->writeI64(_iter217->first);
      xfer += oprot->writeI32(_iter217->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExchangeOpsReq &a, ExchangeOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.destuid, b.destuid);
  swap(a.price, b.price);
  swap(a.items, b.items);
  swap(a.__isset, b.__isset);
}

const char* ExchangeOpsRet::ascii_fingerprint = "EE909F74D5F174CFD2FAC9159A25548A";
const uint8_t ExchangeOpsRet::binary_fingerprint[16] = {0xEE,0x90,0x9F,0x74,0xD5,0xF1,0x74,0xCF,0xD2,0xFA,0xC9,0x15,0x9A,0x25,0x54,0x8A};

uint32_t ExchangeOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->destuid);
          this->__isset.destuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->price);
          this->__isset.price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->items.clear();
            uint32_t _size218;
            ::apache::thrift::protocol::TType _etype221;
            xfer += iprot->readListBegin(_etype221, _size218);
            this->items.resize(_size218);
            uint32_t _i222;
            for (_i222 = 0; _i222 < _size218; ++_i222)
            {
              xfer += this->items[_i222].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priceSelf);
          this->__isset.priceSelf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->itemsSelf.clear();
            uint32_t _size223;
            ::apache::thrift::protocol::TType _etype226;
            xfer += iprot->readListBegin(_etype226, _size223);
            this->itemsSelf.resize(_size223);
            uint32_t _i227;
            for (_i227 = 0; _i227 < _size223; ++_i227)
            {
              xfer += this->itemsSelf[_i227].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.itemsSelf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExchangeOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ExchangeOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destuid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->destuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("price", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->items.size()));
    std::vector<Item> ::const_iterator _iter228;
    for (_iter228 = this->items.begin(); _iter228 != this->items.end(); ++_iter228)
    {
      xfer += (*_iter228).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priceSelf", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->priceSelf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemsSelf", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->itemsSelf.size()));
    std::vector<Item> ::const_iterator _iter229;
    for (_iter229 = this->itemsSelf.begin(); _iter229 != this->itemsSelf.end(); ++_iter229)
    {
      xfer += (*_iter229).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExchangeOpsRet &a, ExchangeOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.destuid, b.destuid);
  swap(a.name, b.name);
  swap(a.price, b.price);
  swap(a.items, b.items);
  swap(a.priceSelf, b.priceSelf);
  swap(a.itemsSelf, b.itemsSelf);
  swap(a.__isset, b.__isset);
}

const char* MoneyBankQueryRet::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t MoneyBankQueryRet::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t MoneyBankQueryRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->moneyNum);
          this->__isset.moneyNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MoneyBankQueryRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MoneyBankQueryRet");

  xfer += oprot->writeFieldBegin("moneyNum", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->moneyNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MoneyBankQueryRet &a, MoneyBankQueryRet &b) {
  using ::std::swap;
  swap(a.moneyNum, b.moneyNum);
  swap(a.__isset, b.__isset);
}

const char* MoneyBankOpsReq::ascii_fingerprint = "AA50AC76F3C371A1DD76BA0C17D383F8";
const uint8_t MoneyBankOpsReq::binary_fingerprint[16] = {0xAA,0x50,0xAC,0x76,0xF3,0xC3,0x71,0xA1,0xDD,0x76,0xBA,0x0C,0x17,0xD3,0x83,0xF8};

uint32_t MoneyBankOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          this->__isset.passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MoneyBankOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MoneyBankOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MoneyBankOpsReq &a, MoneyBankOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.num, b.num);
  swap(a.passwd, b.passwd);
  swap(a.__isset, b.__isset);
}

const char* MoneyBankOpsRet::ascii_fingerprint = "B8A7FA093F4BD296ED5A68E585595B52";
const uint8_t MoneyBankOpsRet::binary_fingerprint[16] = {0xB8,0xA7,0xFA,0x09,0x3F,0x4B,0xD2,0x96,0xED,0x5A,0x68,0xE5,0x85,0x59,0x5B,0x52};

uint32_t MoneyBankOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->num);
          this->__isset.num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->isSetPasswd);
          this->__isset.isSetPasswd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MoneyBankOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MoneyBankOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isSetPasswd", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->isSetPasswd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MoneyBankOpsRet &a, MoneyBankOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.num, b.num);
  swap(a.isSetPasswd, b.isSetPasswd);
  swap(a.__isset, b.__isset);
}

const char* ItemExtraOpsReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t ItemExtraOpsReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t ItemExtraOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemExtraOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ItemExtraOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemExtraOpsReq &a, ItemExtraOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* ItemExtraOpsRet::ascii_fingerprint = "96CFED32BA8C2B1DA11AB2B043BC5D7B";
const uint8_t ItemExtraOpsRet::binary_fingerprint[16] = {0x96,0xCF,0xED,0x32,0xBA,0x8C,0x2B,0x1D,0xA1,0x1A,0xB2,0xB0,0x43,0xBC,0x5D,0x7B};

uint32_t ItemExtraOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemExtraOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ItemExtraOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemExtraOpsRet &a, ItemExtraOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uid, b.uid);
  swap(a.gold, b.gold);
  swap(a.__isset, b.__isset);
}

const char* AuctionOpsReq::ascii_fingerprint = "1D45DD0639226495CEE3E5655CA32527";
const uint8_t AuctionOpsReq::binary_fingerprint[16] = {0x1D,0x45,0xDD,0x06,0x39,0x22,0x64,0x95,0xCE,0xE3,0xE5,0x65,0x5C,0xA3,0x25,0x27};

uint32_t AuctionOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemType);
          this->__isset.itemType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minLevel);
          this->__isset.minLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxLevel);
          this->__isset.maxLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->itemSellId);
          this->__isset.itemSellId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sellPrice);
          this->__isset.sellPrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sellNum);
          this->__isset.sellNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sellTime);
          this->__isset.sellTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->auctionId);
          this->__isset.auctionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->quality);
          this->__isset.quality = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AuctionOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuctionOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->itemType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minLevel", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->minLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxLevel", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->maxLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemSellId", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->itemSellId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sellPrice", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->sellPrice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sellNum", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->sellNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sellTime", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->sellTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("auctionId", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->auctionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("quality", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->quality);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuctionOpsReq &a, AuctionOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.name, b.name);
  swap(a.itemType, b.itemType);
  swap(a.minLevel, b.minLevel);
  swap(a.maxLevel, b.maxLevel);
  swap(a.itemSellId, b.itemSellId);
  swap(a.sellPrice, b.sellPrice);
  swap(a.sellNum, b.sellNum);
  swap(a.sellTime, b.sellTime);
  swap(a.auctionId, b.auctionId);
  swap(a.job, b.job);
  swap(a.quality, b.quality);
  swap(a.__isset, b.__isset);
}

const char* AuctionData::ascii_fingerprint = "416AF0DCFC6C47333BEAA8DC7204FFDD";
const uint8_t AuctionData::binary_fingerprint[16] = {0x41,0x6A,0xF0,0xDC,0xFC,0x6C,0x47,0x33,0x3B,0xEA,0xA8,0xDC,0x72,0x04,0xFF,0xDD};

uint32_t AuctionData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->auctionId);
          this->__isset.auctionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sellPrice);
          this->__isset.sellPrice = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sellTime);
          this->__isset.sellTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->item.read(iprot);
          this->__isset.item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->customUid);
          this->__isset.customUid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->customName);
          this->__isset.customName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buyTime);
          this->__isset.buyTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AuctionData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuctionData");

  xfer += oprot->writeFieldBegin("auctionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->auctionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sellPrice", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->sellPrice);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sellTime", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->sellTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("customUid", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->customUid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("customName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->customName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buyTime", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->buyTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuctionData &a, AuctionData &b) {
  using ::std::swap;
  swap(a.auctionId, b.auctionId);
  swap(a.name, b.name);
  swap(a.level, b.level);
  swap(a.sellPrice, b.sellPrice);
  swap(a.sellTime, b.sellTime);
  swap(a.owner, b.owner);
  swap(a.item, b.item);
  swap(a.uid, b.uid);
  swap(a.customUid, b.customUid);
  swap(a.customName, b.customName);
  swap(a.buyTime, b.buyTime);
  swap(a.__isset, b.__isset);
}

const char* AuctionOpsRet::ascii_fingerprint = "6543F7B1AD781F3A87CA685A5F1C12F9";
const uint8_t AuctionOpsRet::binary_fingerprint[16] = {0x65,0x43,0xF7,0xB1,0xAD,0x78,0x1F,0x3A,0x87,0xCA,0x68,0x5A,0x5F,0x1C,0x12,0xF9};

uint32_t AuctionOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->auctionData.clear();
            uint32_t _size230;
            ::apache::thrift::protocol::TType _etype233;
            xfer += iprot->readListBegin(_etype233, _size230);
            this->auctionData.resize(_size230);
            uint32_t _i234;
            for (_i234 = 0; _i234 < _size230; ++_i234)
            {
              xfer += this->auctionData[_i234].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.auctionData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AuctionOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AuctionOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("auctionData", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->auctionData.size()));
    std::vector<AuctionData> ::const_iterator _iter235;
    for (_iter235 = this->auctionData.begin(); _iter235 != this->auctionData.end(); ++_iter235)
    {
      xfer += (*_iter235).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AuctionOpsRet &a, AuctionOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.auctionData, b.auctionData);
  swap(a.__isset, b.__isset);
}

const char* MarriageOpsReq::ascii_fingerprint = "A1B32CCF29CFC0F95AD7746632DD97F0";
const uint8_t MarriageOpsReq::binary_fingerprint[16] = {0xA1,0xB3,0x2C,0xCF,0x29,0xCF,0xC0,0xF9,0x5A,0xD7,0x74,0x66,0x32,0xDD,0x97,0xF0};

uint32_t MarriageOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->visitors.clear();
            uint32_t _size236;
            ::apache::thrift::protocol::TType _etype239;
            xfer += iprot->readListBegin(_etype239, _size236);
            this->visitors.resize(_size236);
            uint32_t _i240;
            for (_i240 = 0; _i240 < _size236; ++_i240)
            {
              xfer += iprot->readString(this->visitors[_i240]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.visitors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->marryUid);
          this->__isset.marryUid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->housePos);
          this->__isset.housePos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->houseItemId);
          this->__isset.houseItemId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->marryId);
          this->__isset.marryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarriageOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MarriageOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("visitors", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->visitors.size()));
    std::vector<std::string> ::const_iterator _iter241;
    for (_iter241 = this->visitors.begin(); _iter241 != this->visitors.end(); ++_iter241)
    {
      xfer += oprot->writeString((*_iter241));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("marryUid", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->marryUid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("housePos", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->housePos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("houseItemId", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->houseItemId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("marryId", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->marryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarriageOpsReq &a, MarriageOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.visitors, b.visitors);
  swap(a.msg, b.msg);
  swap(a.marryUid, b.marryUid);
  swap(a.housePos, b.housePos);
  swap(a.houseItemId, b.houseItemId);
  swap(a.marryId, b.marryId);
  swap(a.__isset, b.__isset);
}

const char* MarriagePlayerMsg::ascii_fingerprint = "527137B907CD72A82F5383F348421B21";
const uint8_t MarriagePlayerMsg::binary_fingerprint[16] = {0x52,0x71,0x37,0xB9,0x07,0xCD,0x72,0xA8,0x2F,0x53,0x83,0xF3,0x48,0x42,0x1B,0x21};

uint32_t MarriagePlayerMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->online);
          this->__isset.online = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarriagePlayerMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MarriagePlayerMsg");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("online", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->online);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarriagePlayerMsg &a, MarriagePlayerMsg &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.online, b.online);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* MarriageItem::ascii_fingerprint = "0D0E376BC3AE6606497788AA82F73617";
const uint8_t MarriageItem::binary_fingerprint[16] = {0x0D,0x0E,0x37,0x6B,0xC3,0xAE,0x66,0x06,0x49,0x77,0x88,0xAA,0x82,0xF7,0x36,0x17};

uint32_t MarriageItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->itemCfgId);
          this->__isset.itemCfgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarriageItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MarriageItem");

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemCfgId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->itemCfgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarriageItem &a, MarriageItem &b) {
  using ::std::swap;
  swap(a.pos, b.pos);
  swap(a.itemCfgId, b.itemCfgId);
  swap(a.__isset, b.__isset);
}

const char* MarriageVisitListBaseInfo::ascii_fingerprint = "DA48BD3FC1173E929FFD92486590E858";
const uint8_t MarriageVisitListBaseInfo::binary_fingerprint[16] = {0xDA,0x48,0xBD,0x3F,0xC1,0x17,0x3E,0x92,0x9F,0xFD,0x92,0x48,0x65,0x90,0xE8,0x58};

uint32_t MarriageVisitListBaseInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->marryId);
          this->__isset.marryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coupleData.clear();
            uint32_t _size242;
            ::apache::thrift::protocol::TType _etype245;
            xfer += iprot->readListBegin(_etype245, _size242);
            this->coupleData.resize(_size242);
            uint32_t _i246;
            for (_i246 = 0; _i246 < _size242; ++_i246)
            {
              xfer += this->coupleData[_i246].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coupleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tmWedding);
          this->__isset.tmWedding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->setupItems.clear();
            uint32_t _size247;
            ::apache::thrift::protocol::TType _etype250;
            xfer += iprot->readListBegin(_etype250, _size247);
            this->setupItems.resize(_size247);
            uint32_t _i251;
            for (_i251 = 0; _i251 < _size247; ++_i251)
            {
              xfer += this->setupItems[_i251].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.setupItems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tianmi);
          this->__isset.tianmi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarriageVisitListBaseInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MarriageVisitListBaseInfo");

  xfer += oprot->writeFieldBegin("marryId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->marryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coupleData", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->coupleData.size()));
    std::vector<MarriagePlayerMsg> ::const_iterator _iter252;
    for (_iter252 = this->coupleData.begin(); _iter252 != this->coupleData.end(); ++_iter252)
    {
      xfer += (*_iter252).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tmWedding", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->tmWedding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setupItems", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->setupItems.size()));
    std::vector<MarriageItem> ::const_iterator _iter253;
    for (_iter253 = this->setupItems.begin(); _iter253 != this->setupItems.end(); ++_iter253)
    {
      xfer += (*_iter253).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tianmi", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->tianmi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarriageVisitListBaseInfo &a, MarriageVisitListBaseInfo &b) {
  using ::std::swap;
  swap(a.marryId, b.marryId);
  swap(a.coupleData, b.coupleData);
  swap(a.tmWedding, b.tmWedding);
  swap(a.setupItems, b.setupItems);
  swap(a.tianmi, b.tianmi);
  swap(a.__isset, b.__isset);
}

const char* MarriageBaseInfo::ascii_fingerprint = "E3A9277ED700D4ED996FEF51096827D6";
const uint8_t MarriageBaseInfo::binary_fingerprint[16] = {0xE3,0xA9,0x27,0x7E,0xD7,0x00,0xD4,0xED,0x99,0x6F,0xEF,0x51,0x09,0x68,0x27,0xD6};

uint32_t MarriageBaseInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->marryId);
          this->__isset.marryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coupleData.clear();
            uint32_t _size254;
            ::apache::thrift::protocol::TType _etype257;
            xfer += iprot->readListBegin(_etype257, _size254);
            this->coupleData.resize(_size254);
            uint32_t _i258;
            for (_i258 = 0; _i258 < _size254; ++_i258)
            {
              xfer += this->coupleData[_i258].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coupleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listAttends.clear();
            uint32_t _size259;
            ::apache::thrift::protocol::TType _etype262;
            xfer += iprot->readListBegin(_etype262, _size259);
            this->listAttends.resize(_size259);
            uint32_t _i263;
            for (_i263 = 0; _i263 < _size259; ++_i263)
            {
              xfer += this->listAttends[_i263].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listAttends = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->flagXiTie);
          this->__isset.flagXiTie = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->flagWeding);
          this->__isset.flagWeding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tmWedding);
          this->__isset.tmWedding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tianmi);
          this->__isset.tianmi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarriageBaseInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MarriageBaseInfo");

  xfer += oprot->writeFieldBegin("marryId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->marryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coupleData", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->coupleData.size()));
    std::vector<MarriagePlayerMsg> ::const_iterator _iter264;
    for (_iter264 = this->coupleData.begin(); _iter264 != this->coupleData.end(); ++_iter264)
    {
      xfer += (*_iter264).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listAttends", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listAttends.size()));
    std::vector<MarriagePlayerMsg> ::const_iterator _iter265;
    for (_iter265 = this->listAttends.begin(); _iter265 != this->listAttends.end(); ++_iter265)
    {
      xfer += (*_iter265).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flagXiTie", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->flagXiTie);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flagWeding", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->flagWeding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tmWedding", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->tmWedding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tianmi", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->tianmi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarriageBaseInfo &a, MarriageBaseInfo &b) {
  using ::std::swap;
  swap(a.marryId, b.marryId);
  swap(a.coupleData, b.coupleData);
  swap(a.listAttends, b.listAttends);
  swap(a.flagXiTie, b.flagXiTie);
  swap(a.flagWeding, b.flagWeding);
  swap(a.tmWedding, b.tmWedding);
  swap(a.tianmi, b.tianmi);
  swap(a.__isset, b.__isset);
}

const char* MarriageOpsMsgRet::ascii_fingerprint = "13179DC03889888469178D5F6F40ACF9";
const uint8_t MarriageOpsMsgRet::binary_fingerprint[16] = {0x13,0x17,0x9D,0xC0,0x38,0x89,0x88,0x84,0x69,0x17,0x8D,0x5F,0x6F,0x40,0xAC,0xF9};

uint32_t MarriageOpsMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->baseInfo.read(iprot);
          this->__isset.baseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->allMarriageInfo.clear();
            uint32_t _size266;
            ::apache::thrift::protocol::TType _etype269;
            xfer += iprot->readListBegin(_etype269, _size266);
            this->allMarriageInfo.resize(_size266);
            uint32_t _i270;
            for (_i270 = 0; _i270 < _size266; ++_i270)
            {
              xfer += this->allMarriageInfo[_i270].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.allMarriageInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->delTime);
          this->__isset.delTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->getItems.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _etype274;
            xfer += iprot->readListBegin(_etype274, _size271);
            this->getItems.resize(_size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              xfer += this->getItems[_i275].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.getItems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->setupItems.clear();
            uint32_t _size276;
            ::apache::thrift::protocol::TType _etype279;
            xfer += iprot->readListBegin(_etype279, _size276);
            this->setupItems.resize(_size276);
            uint32_t _i280;
            for (_i280 = 0; _i280 < _size276; ++_i280)
            {
              xfer += this->setupItems[_i280].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.setupItems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->argPlayer.read(iprot);
          this->__isset.argPlayer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->weddingSkillId);
          this->__isset.weddingSkillId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listVisitHouseInfo.clear();
            uint32_t _size281;
            ::apache::thrift::protocol::TType _etype284;
            xfer += iprot->readListBegin(_etype284, _size281);
            this->listVisitHouseInfo.resize(_size281);
            uint32_t _i285;
            for (_i285 = 0; _i285 < _size281; ++_i285)
            {
              xfer += this->listVisitHouseInfo[_i285].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listVisitHouseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->otherHouseInfo.read(iprot);
          this->__isset.otherHouseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarriageOpsMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MarriageOpsMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("baseInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->baseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("allMarriageInfo", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->allMarriageInfo.size()));
    std::vector<MarriageBaseInfo> ::const_iterator _iter286;
    for (_iter286 = this->allMarriageInfo.begin(); _iter286 != this->allMarriageInfo.end(); ++_iter286)
    {
      xfer += (*_iter286).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->delTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("getItems", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->getItems.size()));
    std::vector<Item> ::const_iterator _iter287;
    for (_iter287 = this->getItems.begin(); _iter287 != this->getItems.end(); ++_iter287)
    {
      xfer += (*_iter287).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setupItems", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->setupItems.size()));
    std::vector<MarriageItem> ::const_iterator _iter288;
    for (_iter288 = this->setupItems.begin(); _iter288 != this->setupItems.end(); ++_iter288)
    {
      xfer += (*_iter288).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("argPlayer", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->argPlayer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("weddingSkillId", ::apache::thrift::protocol::T_I16, 10);
  xfer += oprot->writeI16(this->weddingSkillId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listVisitHouseInfo", ::apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listVisitHouseInfo.size()));
    std::vector<MarriageVisitListBaseInfo> ::const_iterator _iter289;
    for (_iter289 = this->listVisitHouseInfo.begin(); _iter289 != this->listVisitHouseInfo.end(); ++_iter289)
    {
      xfer += (*_iter289).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("otherHouseInfo", ::apache::thrift::protocol::T_STRUCT, 12);
  xfer += this->otherHouseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarriageOpsMsgRet &a, MarriageOpsMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.baseInfo, b.baseInfo);
  swap(a.allMarriageInfo, b.allMarriageInfo);
  swap(a.delTime, b.delTime);
  swap(a.msg, b.msg);
  swap(a.gold, b.gold);
  swap(a.getItems, b.getItems);
  swap(a.setupItems, b.setupItems);
  swap(a.argPlayer, b.argPlayer);
  swap(a.weddingSkillId, b.weddingSkillId);
  swap(a.listVisitHouseInfo, b.listVisitHouseInfo);
  swap(a.otherHouseInfo, b.otherHouseInfo);
  swap(a.__isset, b.__isset);
}

const char* MarriageUpdateRet::ascii_fingerprint = "38FC8A5F285FF0DDA20FCD1764099CC1";
const uint8_t MarriageUpdateRet::binary_fingerprint[16] = {0x38,0xFC,0x8A,0x5F,0x28,0x5F,0xF0,0xDD,0xA2,0x0F,0xCD,0x17,0x64,0x09,0x9C,0xC1};

uint32_t MarriageUpdateRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->matePlayer.read(iprot);
          this->__isset.matePlayer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->goldPlayer.read(iprot);
          this->__isset.goldPlayer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MarriageUpdateRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MarriageUpdateRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matePlayer", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->matePlayer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("goldPlayer", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->goldPlayer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MarriageUpdateRet &a, MarriageUpdateRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.matePlayer, b.matePlayer);
  swap(a.status, b.status);
  swap(a.goldPlayer, b.goldPlayer);
  swap(a.__isset, b.__isset);
}

const char* ArenaOpsReq::ascii_fingerprint = "20DA9587E05B8AE447265A7CDB61F8EB";
const uint8_t ArenaOpsReq::binary_fingerprint[16] = {0x20,0xDA,0x95,0x87,0xE0,0x5B,0x8A,0xE4,0x47,0x26,0x5A,0x7C,0xDB,0x61,0xF8,0xEB};

uint32_t ArenaOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->idArg);
          this->__isset.idArg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numArg);
          this->__isset.numArg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->destuid);
          this->__isset.destuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ArenaOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ArenaOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("idArg", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->idArg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("numArg", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->numArg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destuid", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->destuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ArenaOpsReq &a, ArenaOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.idArg, b.idArg);
  swap(a.numArg, b.numArg);
  swap(a.destuid, b.destuid);
  swap(a.__isset, b.__isset);
}

const char* ArenaPlayerData::ascii_fingerprint = "2A0E5B517452E50F4858512A70256A34";
const uint8_t ArenaPlayerData::binary_fingerprint[16] = {0x2A,0x0E,0x5B,0x51,0x74,0x52,0xE5,0x0F,0x48,0x58,0x51,0x2A,0x70,0x25,0x6A,0x34};

uint32_t ArenaPlayerData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fightPower);
          this->__isset.fightPower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rank);
          this->__isset.rank = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ArenaPlayerData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ArenaPlayerData");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fightPower", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->fightPower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rank", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->rank);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ArenaPlayerData &a, ArenaPlayerData &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.fightPower, b.fightPower);
  swap(a.rank, b.rank);
  swap(a.__isset, b.__isset);
}

const char* ArenaScore2Item::ascii_fingerprint = "13FECAD7482462471BF31A8061B88475";
const uint8_t ArenaScore2Item::binary_fingerprint[16] = {0x13,0xFE,0xCA,0xD7,0x48,0x24,0x62,0x47,0x1B,0xF3,0x1A,0x80,0x61,0xB8,0x84,0x75};

uint32_t ArenaScore2Item::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->score);
          this->__isset.score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->item.read(iprot);
          this->__isset.item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ArenaScore2Item::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ArenaScore2Item");

  xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->score);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ArenaScore2Item &a, ArenaScore2Item &b) {
  using ::std::swap;
  swap(a.score, b.score);
  swap(a.item, b.item);
  swap(a.__isset, b.__isset);
}

const char* ArenaOpsRet::ascii_fingerprint = "D87C7C1C7BB4408C198A5449A6C5C934";
const uint8_t ArenaOpsRet::binary_fingerprint[16] = {0xD8,0x7C,0x7C,0x1C,0x7B,0xB4,0x40,0x8C,0x19,0x8A,0x54,0x49,0xA6,0xC5,0xC9,0x34};

uint32_t ArenaOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leftChallengeTimes);
          this->__isset.leftChallengeTimes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->score);
          this->__isset.score = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rank);
          this->__isset.rank = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listPlayers.clear();
            uint32_t _size290;
            ::apache::thrift::protocol::TType _etype293;
            xfer += iprot->readListBegin(_etype293, _size290);
            this->listPlayers.resize(_size290);
            uint32_t _i294;
            for (_i294 = 0; _i294 < _size290; ++_i294)
            {
              xfer += this->listPlayers[_i294].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listPlayers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listItems.clear();
            uint32_t _size295;
            ::apache::thrift::protocol::TType _etype298;
            xfer += iprot->readListBegin(_etype298, _size295);
            this->listItems.resize(_size295);
            uint32_t _i299;
            for (_i299 = 0; _i299 < _size295; ++_i299)
            {
              xfer += this->listItems[_i299].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listItems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ArenaOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ArenaOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leftChallengeTimes", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->leftChallengeTimes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->score);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rank", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->rank);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listPlayers", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listPlayers.size()));
    std::vector<ArenaPlayerData> ::const_iterator _iter300;
    for (_iter300 = this->listPlayers.begin(); _iter300 != this->listPlayers.end(); ++_iter300)
    {
      xfer += (*_iter300).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listItems", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listItems.size()));
    std::vector<ArenaScore2Item> ::const_iterator _iter301;
    for (_iter301 = this->listItems.begin(); _iter301 != this->listItems.end(); ++_iter301)
    {
      xfer += (*_iter301).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ArenaOpsRet &a, ArenaOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.leftChallengeTimes, b.leftChallengeTimes);
  swap(a.score, b.score);
  swap(a.rank, b.rank);
  swap(a.listPlayers, b.listPlayers);
  swap(a.listItems, b.listItems);
  swap(a.__isset, b.__isset);
}

const char* QieCuoReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t QieCuoReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t QieCuoReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidarg);
          this->__isset.uidarg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QieCuoReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QieCuoReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uidarg", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uidarg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QieCuoReq &a, QieCuoReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uidarg, b.uidarg);
  swap(a.__isset, b.__isset);
}

const char* QieCuoRet::ascii_fingerprint = "BB76792ED9AEEFB3608F6A321C7E0260";
const uint8_t QieCuoRet::binary_fingerprint[16] = {0xBB,0x76,0x79,0x2E,0xD9,0xAE,0xEF,0xB3,0x60,0x8F,0x6A,0x32,0x1C,0x7E,0x02,0x60};

uint32_t QieCuoRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->infoPlayer.read(iprot);
          this->__isset.infoPlayer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->winUid);
          this->__isset.winUid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t QieCuoRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("QieCuoRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infoPlayer", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->infoPlayer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("winUid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->winUid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(QieCuoRet &a, QieCuoRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.infoPlayer, b.infoPlayer);
  swap(a.winUid, b.winUid);
  swap(a.__isset, b.__isset);
}

const char* MailOpsReq::ascii_fingerprint = "22E53976F5A5E1DAFC267F06CABE286F";
const uint8_t MailOpsReq::binary_fingerprint[16] = {0x22,0xE5,0x39,0x76,0xF5,0xA5,0xE1,0xDA,0xFC,0x26,0x7F,0x06,0xCA,0xBE,0x28,0x6F};

uint32_t MailOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mailId);
          this->__isset.mailId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sendToUid);
          this->__isset.sendToUid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast302;
          xfer += iprot->readI32(ecast302);
          this->sendTgtType = (MailMsgType::type)ecast302;
          this->__isset.sendTgtType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MailOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MailOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mailId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->mailId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sendToUid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->sendToUid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sendTgtType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->sendTgtType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MailOpsReq &a, MailOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.mailId, b.mailId);
  swap(a.sendToUid, b.sendToUid);
  swap(a.sendTgtType, b.sendTgtType);
  swap(a.title, b.title);
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

const char* MailPlayerMsg::ascii_fingerprint = "AA8FBFDE43AA8831121986F0B5BC34BC";
const uint8_t MailPlayerMsg::binary_fingerprint[16] = {0xAA,0x8F,0xBF,0xDE,0x43,0xAA,0x88,0x31,0x12,0x19,0x86,0xF0,0xB5,0xBC,0x34,0xBC};

uint32_t MailPlayerMsg::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->gender);
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->online);
          this->__isset.online = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MailPlayerMsg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MailPlayerMsg");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->gender);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("online", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->online);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MailPlayerMsg &a, MailPlayerMsg &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.name, b.name);
  swap(a.job, b.job);
  swap(a.gender, b.gender);
  swap(a.level, b.level);
  swap(a.online, b.online);
  swap(a.__isset, b.__isset);
}

const char* MailAttachData::ascii_fingerprint = "1AB3A1CF9912FDEF32C4878AE56EE1B0";
const uint8_t MailAttachData::binary_fingerprint[16] = {0x1A,0xB3,0xA1,0xCF,0x99,0x12,0xFD,0xEF,0x32,0xC4,0x87,0x8A,0xE5,0x6E,0xE1,0xB0};

uint32_t MailAttachData::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast303;
          xfer += iprot->readI32(ecast303);
          this->type = (MailAttachType::type)ecast303;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arg1);
          this->__isset.arg1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->arg2);
          this->__isset.arg2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MailAttachData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MailAttachData");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg1", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->arg1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arg2", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->arg2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MailAttachData &a, MailAttachData &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.arg1, b.arg1);
  swap(a.arg2, b.arg2);
  swap(a.__isset, b.__isset);
}

const char* MailDataNode::ascii_fingerprint = "E91B62C3B17536E03DE1C28955722AB0";
const uint8_t MailDataNode::binary_fingerprint[16] = {0xE9,0x1B,0x62,0xC3,0xB1,0x75,0x36,0xE0,0x3D,0xE1,0xC2,0x89,0x55,0x72,0x2A,0xB0};

uint32_t MailDataNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mailId);
          this->__isset.mailId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast304;
          xfer += iprot->readI32(ecast304);
          this->msgType = (MailMsgType::type)ecast304;
          this->__isset.msgType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sender.read(iprot);
          this->__isset.sender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listAttach.clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _etype308;
            xfer += iprot->readListBegin(_etype308, _size305);
            this->listAttach.resize(_size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              xfer += this->listAttach[_i309].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listAttach = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sendTime);
          this->__isset.sendTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast310;
          xfer += iprot->readI32(ecast310);
          this->status = (MailStatusType::type)ecast310;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MailDataNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MailDataNode");

  xfer += oprot->writeFieldBegin("mailId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->mailId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msgType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->msgType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sender", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->sender.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->title);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listAttach", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listAttach.size()));
    std::vector<MailAttachData> ::const_iterator _iter311;
    for (_iter311 = this->listAttach.begin(); _iter311 != this->listAttach.end(); ++_iter311)
    {
      xfer += (*_iter311).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sendTime", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->sendTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MailDataNode &a, MailDataNode &b) {
  using ::std::swap;
  swap(a.mailId, b.mailId);
  swap(a.msgType, b.msgType);
  swap(a.sender, b.sender);
  swap(a.title, b.title);
  swap(a.msg, b.msg);
  swap(a.listAttach, b.listAttach);
  swap(a.sendTime, b.sendTime);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

const char* MailOpsRet::ascii_fingerprint = "5773F9B33294C90DA0A0124D420EC87E";
const uint8_t MailOpsRet::binary_fingerprint[16] = {0x57,0x73,0xF9,0xB3,0x32,0x94,0xC9,0x0D,0xA0,0xA0,0x12,0x4D,0x42,0x0E,0xC8,0x7E};

uint32_t MailOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listAllMaill.clear();
            uint32_t _size312;
            ::apache::thrift::protocol::TType _etype315;
            xfer += iprot->readListBegin(_etype315, _size312);
            this->listAllMaill.resize(_size312);
            uint32_t _i316;
            for (_i316 = 0; _i316 < _size312; ++_i316)
            {
              xfer += this->listAllMaill[_i316].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listAllMaill = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->opMailId);
          this->__isset.opMailId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listNewMail.clear();
            uint32_t _size317;
            ::apache::thrift::protocol::TType _etype320;
            xfer += iprot->readListBegin(_etype320, _size317);
            this->listNewMail.resize(_size317);
            uint32_t _i321;
            for (_i321 = 0; _i321 < _size317; ++_i321)
            {
              xfer += this->listNewMail[_i321].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listNewMail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MailOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MailOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listAllMaill", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listAllMaill.size()));
    std::vector<MailDataNode> ::const_iterator _iter322;
    for (_iter322 = this->listAllMaill.begin(); _iter322 != this->listAllMaill.end(); ++_iter322)
    {
      xfer += (*_iter322).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("opMailId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->opMailId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listNewMail", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listNewMail.size()));
    std::vector<MailDataNode> ::const_iterator _iter323;
    for (_iter323 = this->listNewMail.begin(); _iter323 != this->listNewMail.end(); ++_iter323)
    {
      xfer += (*_iter323).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MailOpsRet &a, MailOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.listAllMaill, b.listAllMaill);
  swap(a.opMailId, b.opMailId);
  swap(a.listNewMail, b.listNewMail);
  swap(a.__isset, b.__isset);
}

const char* AttackModeReq::ascii_fingerprint = "C88FB7958D86460D03E699333A272947";
const uint8_t AttackModeReq::binary_fingerprint[16] = {0xC8,0x8F,0xB7,0x95,0x8D,0x86,0x46,0x0D,0x03,0xE6,0x99,0x33,0x3A,0x27,0x29,0x47};

uint32_t AttackModeReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->modeAttack);
          this->__isset.modeAttack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AttackModeReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AttackModeReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modeAttack", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->modeAttack);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AttackModeReq &a, AttackModeReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.modeAttack, b.modeAttack);
  swap(a.__isset, b.__isset);
}

const char* AttackModeRet::ascii_fingerprint = "C88FB7958D86460D03E699333A272947";
const uint8_t AttackModeRet::binary_fingerprint[16] = {0xC8,0x8F,0xB7,0x95,0x8D,0x86,0x46,0x0D,0x03,0xE6,0x99,0x33,0x3A,0x27,0x29,0x47};

uint32_t AttackModeRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->modeAttack);
          this->__isset.modeAttack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AttackModeRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("AttackModeRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("modeAttack", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->modeAttack);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AttackModeRet &a, AttackModeRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.modeAttack, b.modeAttack);
  swap(a.__isset, b.__isset);
}

const char* PkSinUpdateRet::ascii_fingerprint = "D1C8F64A72386C4D1ECD0031C48A65ED";
const uint8_t PkSinUpdateRet::binary_fingerprint[16] = {0xD1,0xC8,0xF6,0x4A,0x72,0x38,0x6C,0x4D,0x1E,0xCD,0x00,0x31,0xC4,0x8A,0x65,0xED};

uint32_t PkSinUpdateRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->pkSinValue);
          this->__isset.pkSinValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PkSinUpdateRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("PkSinUpdateRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pkSinValue", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->pkSinValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PkSinUpdateRet &a, PkSinUpdateRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.pkSinValue, b.pkSinValue);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* HelpAttackReq::ascii_fingerprint = "C25B226C0437EA93A910AE3DEFEFCBF8";
const uint8_t HelpAttackReq::binary_fingerprint[16] = {0xC2,0x5B,0x22,0x6C,0x04,0x37,0xEA,0x93,0xA9,0x10,0xAE,0x3D,0xEF,0xEF,0xCB,0xF8};

uint32_t HelpAttackReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uidArg);
          this->__isset.uidArg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HelpAttackReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HelpAttackReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uidArg", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->uidArg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HelpAttackReq &a, HelpAttackReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.uidArg, b.uidArg);
  swap(a.__isset, b.__isset);
}

const char* HelpAttackRet::ascii_fingerprint = "B5711951AC56EA394C013DEE38B0B24B";
const uint8_t HelpAttackRet::binary_fingerprint[16] = {0xB5,0x71,0x19,0x51,0xAC,0x56,0xEA,0x39,0x4C,0x01,0x3D,0xEE,0x38,0xB0,0xB2,0x4B};

uint32_t HelpAttackRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->infoPlayer.read(iprot);
          this->__isset.infoPlayer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HelpAttackRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HelpAttackRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infoPlayer", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->infoPlayer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HelpAttackRet &a, HelpAttackRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.infoPlayer, b.infoPlayer);
  swap(a.__isset, b.__isset);
}

const char* RebornRet::ascii_fingerprint = "81B5431BF2E3C4997A29AB960D3D0FED";
const uint8_t RebornRet::binary_fingerprint[16] = {0x81,0xB5,0x43,0x1B,0xF2,0xE3,0xC4,0x99,0x7A,0x29,0xAB,0x96,0x0D,0x3D,0x0F,0xED};

uint32_t RebornRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->bornPlayerInfo.read(iprot);
          this->__isset.bornPlayerInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RebornRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RebornRet");

  xfer += oprot->writeFieldBegin("bornPlayerInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->bornPlayerInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RebornRet &a, RebornRet &b) {
  using ::std::swap;
  swap(a.bornPlayerInfo, b.bornPlayerInfo);
  swap(a.__isset, b.__isset);
}

const char* XibaiReq::ascii_fingerprint = "565787C31CF2D774B532CB755189BF39";
const uint8_t XibaiReq::binary_fingerprint[16] = {0x56,0x57,0x87,0xC3,0x1C,0xF2,0xD7,0x74,0xB5,0x32,0xCB,0x75,0x51,0x89,0xBF,0x39};

uint32_t XibaiReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t XibaiReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("XibaiReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(XibaiReq &a, XibaiReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.__isset, b.__isset);
}

const char* XibaiRet::ascii_fingerprint = "0D0E376BC3AE6606497788AA82F73617";
const uint8_t XibaiRet::binary_fingerprint[16] = {0x0D,0x0E,0x37,0x6B,0xC3,0xAE,0x66,0x06,0x49,0x77,0x88,0xAA,0x82,0xF7,0x36,0x17};

uint32_t XibaiRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->costGold);
          this->__isset.costGold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t XibaiRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("XibaiRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("costGold", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->costGold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(XibaiRet &a, XibaiRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.costGold, b.costGold);
  swap(a.__isset, b.__isset);
}

const char* RankOpsReq::ascii_fingerprint = "C88FB7958D86460D03E699333A272947";
const uint8_t RankOpsReq::binary_fingerprint[16] = {0xC8,0x8F,0xB7,0x95,0x8D,0x86,0x46,0x0D,0x03,0xE6,0x99,0x33,0x3A,0x27,0x29,0x47};

uint32_t RankOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->ranktype);
          this->__isset.ranktype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RankOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RankOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ranktype", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->ranktype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RankOpsReq &a, RankOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.ranktype, b.ranktype);
  swap(a.__isset, b.__isset);
}

const char* RankDataNode::ascii_fingerprint = "D28A235346CAFDF61809941595C05A96";
const uint8_t RankDataNode::binary_fingerprint[16] = {0xD2,0x8A,0x23,0x53,0x46,0xCA,0xFD,0xF6,0x18,0x09,0x94,0x15,0x95,0xC0,0x5A,0x96};

uint32_t RankDataNode::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->rank);
          this->__isset.rank = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->job);
          this->__isset.job = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->fightpower);
          this->__isset.fightpower = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guild_name);
          this->__isset.guild_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guild_id);
          this->__isset.guild_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RankDataNode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RankDataNode");

  xfer += oprot->writeFieldBegin("rank", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->rank);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("job", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->job);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fightpower", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->fightpower);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guild_name", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->guild_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guild_id", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->guild_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RankDataNode &a, RankDataNode &b) {
  using ::std::swap;
  swap(a.rank, b.rank);
  swap(a.name, b.name);
  swap(a.uid, b.uid);
  swap(a.job, b.job);
  swap(a.level, b.level);
  swap(a.fightpower, b.fightpower);
  swap(a.gold, b.gold);
  swap(a.count, b.count);
  swap(a.guild_name, b.guild_name);
  swap(a.guild_id, b.guild_id);
  swap(a.__isset, b.__isset);
}

const char* RankOpsRet::ascii_fingerprint = "9CA6D968CC18090F337C2B11E0D0BB1C";
const uint8_t RankOpsRet::binary_fingerprint[16] = {0x9C,0xA6,0xD9,0x68,0xCC,0x18,0x09,0x0F,0x33,0x7C,0x2B,0x11,0xE0,0xD0,0xBB,0x1C};

uint32_t RankOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->ranktype);
          this->__isset.ranktype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->listRank.clear();
            uint32_t _size324;
            ::apache::thrift::protocol::TType _etype327;
            xfer += iprot->readListBegin(_etype327, _size324);
            this->listRank.resize(_size324);
            uint32_t _i328;
            for (_i328 = 0; _i328 < _size324; ++_i328)
            {
              xfer += this->listRank[_i328].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.listRank = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RankOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("RankOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ranktype", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->ranktype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("listRank", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->listRank.size()));
    std::vector<RankDataNode> ::const_iterator _iter329;
    for (_iter329 = this->listRank.begin(); _iter329 != this->listRank.end(); ++_iter329)
    {
      xfer += (*_iter329).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RankOpsRet &a, RankOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.ranktype, b.ranktype);
  swap(a.listRank, b.listRank);
  swap(a.__isset, b.__isset);
}

const char* HeartBeatReq::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t HeartBeatReq::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t HeartBeatReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->arg);
          this->__isset.arg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartBeatReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HeartBeatReq");

  xfer += oprot->writeFieldBegin("arg", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->arg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartBeatReq &a, HeartBeatReq &b) {
  using ::std::swap;
  swap(a.arg, b.arg);
  swap(a.__isset, b.__isset);
}

const char* HeartBeatRet::ascii_fingerprint = "E86CACEB22240450EDCBEFC3A83970E4";
const uint8_t HeartBeatRet::binary_fingerprint[16] = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

uint32_t HeartBeatRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->arg);
          this->__isset.arg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartBeatRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("HeartBeatRet");

  xfer += oprot->writeFieldBegin("arg", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->arg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartBeatRet &a, HeartBeatRet &b) {
  using ::std::swap;
  swap(a.arg, b.arg);
  swap(a.__isset, b.__isset);
}

const char* GuildWarOpsReq::ascii_fingerprint = "55F2239516C9C08DB41231C56B29843E";
const uint8_t GuildWarOpsReq::binary_fingerprint[16] = {0x55,0xF2,0x23,0x95,0x16,0xC9,0xC0,0x8D,0xB4,0x12,0x31,0xC5,0x6B,0x29,0x84,0x3E};

uint32_t GuildWarOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->guildID);
          this->__isset.guildID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->guildName);
          this->__isset.guildName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildWarOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildWarOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildID", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->guildID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guildName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->guildName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildWarOpsReq &a, GuildWarOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.guildID, b.guildID);
  swap(a.guildName, b.guildName);
  swap(a.__isset, b.__isset);
}

const char* GuildWarOtherInfo::ascii_fingerprint = "A79BF4F9EDF5A08D9A78B12DE92B4D82";
const uint8_t GuildWarOtherInfo::binary_fingerprint[16] = {0xA7,0x9B,0xF4,0xF9,0xED,0xF5,0xA0,0x8D,0x9A,0x78,0xB1,0x2D,0xE9,0x2B,0x4D,0x82};

uint32_t GuildWarOtherInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tmWarStart);
          this->__isset.tmWarStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->warApplyGuild.read(iprot);
          this->__isset.warApplyGuild = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->warFightGuild.read(iprot);
          this->__isset.warFightGuild = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildWarOtherInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildWarOtherInfo");

  xfer += oprot->writeFieldBegin("tmWarStart", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->tmWarStart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("warApplyGuild", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->warApplyGuild.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("warFightGuild", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->warFightGuild.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildWarOtherInfo &a, GuildWarOtherInfo &b) {
  using ::std::swap;
  swap(a.tmWarStart, b.tmWarStart);
  swap(a.warApplyGuild, b.warApplyGuild);
  swap(a.warFightGuild, b.warFightGuild);
  swap(a.__isset, b.__isset);
}

const char* GuildWarOpsRet::ascii_fingerprint = "E26353D57BD4E85F7BED6BAC65CA35D1";
const uint8_t GuildWarOpsRet::binary_fingerprint[16] = {0xE2,0x63,0x53,0xD5,0x7B,0xD4,0xE8,0x5F,0x7B,0xED,0x6B,0xAC,0x65,0xCA,0x35,0xD1};

uint32_t GuildWarOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tmWarStart);
          this->__isset.tmWarStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->warApplyGuild.read(iprot);
          this->__isset.warApplyGuild = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->warFightGuild.read(iprot);
          this->__isset.warFightGuild = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->warListInfo.clear();
            uint32_t _size330;
            ::apache::thrift::protocol::TType _etype333;
            xfer += iprot->readListBegin(_etype333, _size330);
            this->warListInfo.resize(_size330);
            uint32_t _i334;
            for (_i334 = 0; _i334 < _size330; ++_i334)
            {
              xfer += this->warListInfo[_i334].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.warListInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->winGuildId);
          this->__isset.winGuildId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildWarOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildWarOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tmWarStart", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->tmWarStart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("warApplyGuild", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->warApplyGuild.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("warFightGuild", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->warFightGuild.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("warListInfo", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->warListInfo.size()));
    std::vector<GuildWarOtherInfo> ::const_iterator _iter335;
    for (_iter335 = this->warListInfo.begin(); _iter335 != this->warListInfo.end(); ++_iter335)
    {
      xfer += (*_iter335).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("winGuildId", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->winGuildId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildWarOpsRet &a, GuildWarOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.tmWarStart, b.tmWarStart);
  swap(a.warApplyGuild, b.warApplyGuild);
  swap(a.warFightGuild, b.warFightGuild);
  swap(a.warListInfo, b.warListInfo);
  swap(a.winGuildId, b.winGuildId);
  swap(a.__isset, b.__isset);
}

const char* GuildCityWarOpsMsgReq::ascii_fingerprint = "565787C31CF2D774B532CB755189BF39";
const uint8_t GuildCityWarOpsMsgReq::binary_fingerprint[16] = {0x56,0x57,0x87,0xC3,0x1C,0xF2,0xD7,0x74,0xB5,0x32,0xCB,0x75,0x51,0x89,0xBF,0x39};

uint32_t GuildCityWarOpsMsgReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildCityWarOpsMsgReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildCityWarOpsMsgReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildCityWarOpsMsgReq &a, GuildCityWarOpsMsgReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.__isset, b.__isset);
}

const char* GuildCityWarOpsMsgRet::ascii_fingerprint = "25BE27070FA03E34FBE9F8765EAB583F";
const uint8_t GuildCityWarOpsMsgRet::binary_fingerprint[16] = {0x25,0xBE,0x27,0x07,0x0F,0xA0,0x3E,0x34,0xFB,0xE9,0xF8,0x76,0x5E,0xAB,0x58,0x3F};

uint32_t GuildCityWarOpsMsgRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->attack_result);
          this->__isset.attack_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->curApplyList.clear();
            uint32_t _size336;
            ::apache::thrift::protocol::TType _etype339;
            xfer += iprot->readListBegin(_etype339, _size336);
            this->curApplyList.resize(_size336);
            uint32_t _i340;
            for (_i340 = 0; _i340 < _size336; ++_i340)
            {
              xfer += this->curApplyList[_i340].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.curApplyList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->tmStart);
          this->__isset.tmStart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->curMaster.read(iprot);
          this->__isset.curMaster = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GuildCityWarOpsMsgRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("GuildCityWarOpsMsgRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attack_result", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->attack_result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curApplyList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->curApplyList.size()));
    std::vector<GuildInfoMsg> ::const_iterator _iter341;
    for (_iter341 = this->curApplyList.begin(); _iter341 != this->curApplyList.end(); ++_iter341)
    {
      xfer += (*_iter341).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tmStart", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->tmStart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curMaster", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->curMaster.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GuildCityWarOpsMsgRet &a, GuildCityWarOpsMsgRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.attack_result, b.attack_result);
  swap(a.curApplyList, b.curApplyList);
  swap(a.tmStart, b.tmStart);
  swap(a.curMaster, b.curMaster);
  swap(a.__isset, b.__isset);
}

const char* ChangeApprRet::ascii_fingerprint = "F5482C93CA1806422ACA56B615045E1E";
const uint8_t ChangeApprRet::binary_fingerprint[16] = {0xF5,0x48,0x2C,0x93,0xCA,0x18,0x06,0x42,0x2A,0xCA,0x56,0xB6,0x15,0x04,0x5E,0x1E};

uint32_t ChangeApprRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nameColor);
          this->__isset.nameColor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->xiongJiaCfgId);
          this->__isset.xiongJiaCfgId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChangeApprRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ChangeApprRet");

  xfer += oprot->writeFieldBegin("nameColor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->nameColor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xiongJiaCfgId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->xiongJiaCfgId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChangeApprRet &a, ChangeApprRet &b) {
  using ::std::swap;
  swap(a.nameColor, b.nameColor);
  swap(a.xiongJiaCfgId, b.xiongJiaCfgId);
  swap(a.uid, b.uid);
  swap(a.__isset, b.__isset);
}

const char* DailyLoginOpsReq::ascii_fingerprint = "C88FB7958D86460D03E699333A272947";
const uint8_t DailyLoginOpsReq::binary_fingerprint[16] = {0xC8,0x8F,0xB7,0x95,0x8D,0x86,0x46,0x0D,0x03,0xE6,0x99,0x33,0x3A,0x27,0x29,0x47};

uint32_t DailyLoginOpsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->reward_id);
          this->__isset.reward_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DailyLoginOpsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DailyLoginOpsReq");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("reward_id", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->reward_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DailyLoginOpsReq &a, DailyLoginOpsReq &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.reward_id, b.reward_id);
  swap(a.__isset, b.__isset);
}

const char* DailyLoginInfo::ascii_fingerprint = "3AF48A00FA68BE4FE77AAA79C8B19CAD";
const uint8_t DailyLoginInfo::binary_fingerprint[16] = {0x3A,0xF4,0x8A,0x00,0xFA,0x68,0xBE,0x4F,0xE7,0x7A,0xAA,0x79,0xC8,0xB1,0x9C,0xAD};

uint32_t DailyLoginInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->seven_login_days);
          this->__isset.seven_login_days = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->seven_login_mask);
          this->__isset.seven_login_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->online_time);
          this->__isset.online_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->online_reward_mask);
          this->__isset.online_reward_mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->invite_reward);
          this->__isset.invite_reward = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DailyLoginInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DailyLoginInfo");

  xfer += oprot->writeFieldBegin("seven_login_days", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->seven_login_days);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("seven_login_mask", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->seven_login_mask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("online_time", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->online_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("online_reward_mask", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->online_reward_mask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("invite_reward", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->invite_reward);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DailyLoginInfo &a, DailyLoginInfo &b) {
  using ::std::swap;
  swap(a.seven_login_days, b.seven_login_days);
  swap(a.seven_login_mask, b.seven_login_mask);
  swap(a.online_time, b.online_time);
  swap(a.online_reward_mask, b.online_reward_mask);
  swap(a.invite_reward, b.invite_reward);
  swap(a.__isset, b.__isset);
}

const char* DailyLoginOpsRet::ascii_fingerprint = "EEE5F211280BEE68757CBC92C745A3C0";
const uint8_t DailyLoginOpsRet::binary_fingerprint[16] = {0xEE,0xE5,0xF2,0x11,0x28,0x0B,0xEE,0x68,0x75,0x7C,0xBC,0x92,0xC7,0x45,0xA3,0xC0};

uint32_t DailyLoginOpsRet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->opstype);
          this->__isset.opstype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dailyInfo.read(iprot);
          this->__isset.dailyInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->items.clear();
            uint32_t _size342;
            ::apache::thrift::protocol::TType _etype345;
            xfer += iprot->readListBegin(_etype345, _size342);
            this->items.resize(_size342);
            uint32_t _i346;
            for (_i346 = 0; _i346 < _size342; ++_i346)
            {
              xfer += this->items[_i346].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.items = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->gold);
          this->__isset.gold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DailyLoginOpsRet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DailyLoginOpsRet");

  xfer += oprot->writeFieldBegin("opstype", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->opstype);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dailyInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->dailyInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("items", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->items.size()));
    std::vector<Item> ::const_iterator _iter347;
    for (_iter347 = this->items.begin(); _iter347 != this->items.end(); ++_iter347)
    {
      xfer += (*_iter347).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gold", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->gold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DailyLoginOpsRet &a, DailyLoginOpsRet &b) {
  using ::std::swap;
  swap(a.opstype, b.opstype);
  swap(a.dailyInfo, b.dailyInfo);
  swap(a.items, b.items);
  swap(a.gold, b.gold);
  swap(a.__isset, b.__isset);
}

} // namespace
